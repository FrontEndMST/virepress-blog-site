# 模拟题

## 一：



## 二：



## 三：

#### react合成事件是什么，和原生事件的区别？

react合成事件是react内部实现的事件处理系统，相比于原生事件系统做了诸多优化。比如更好的性能，合成事件采用了事件池设计，event对象不会被销毁，可以重复使用，减小了开销。其次在合成事件中可以自定义event对象的属性，方便我们更好的扩展

```
首先，React合成事件是基于浏览器原生事件机制实现的，但是React会在事件冒泡阶段对原生事件进行包装，形成一个合成事件对象，来统一处理不同浏览器之间的差异。

其次，React合成事件与原生事件的主要区别在于性能和处理方式上。React合成事件采用了事件池技术，可以重用事件对象，减少内存开销，提高性能。此外，React合成事件对事件处理方式进行了优化，例如对于一些事件处理函数会进行批量更新，避免频繁的重新渲染。

最后，React合成事件还提供了一些其他的扩展功能，例如可拖拽、可复制、可粘贴等。在React开发中，一般推荐使用React合成事件来处理用户交互事件，因为它比原生事件更高效、更易用、更可靠。
```



#### react如何处理异常？

react的异常处理通常在类式组件中，可以通过componentDidCatch和should...的两个API对错误进行捕获，他们仅能捕获react所产生的错误，像ErrorBoundery这样捕获下层组件产生错误，ErrorBoundery的设计通过捕获底层组件抛出的Promise实现错误捕获，如果要捕获代码中的错误还是应该使用trycatch

```
在React中，可以通过错误边界（Error Boundaries）机制来捕获和处理组件渲染过程中的异常。错误边界是一种React组件，它可以在其子组件中捕获并处理错误，防止错误的传播影响整个应用的正常运行。

在类组件中，可以使用componentDidCatch()方法来捕获子组件中的错误。当子组件发生错误时，componentDidCatch()方法会被调用，可以在该方法中进行错误的处理、记录或反馈等操作。需要注意的是，componentDidCatch()只能捕获子组件中的错误，而无法捕获在事件处理函数、异步操作和服务端渲染等场景中产生的错误。

另外，React还提供了shouldComponentUpdate()方法来控制组件是否重新渲染。可以在该方法中对组件的状态和属性进行比较，来决定是否需要重新渲染组件。这样可以有效减少组件的渲染次数，提高应用的性能。

需要注意的是，React的错误边界机制并不能完全避免应用的崩溃或异常，因此在开发过程中，还需要注意编写健壮性高的代码，以避免出现意外的错误。
```



#### 闭包的作用和原理？

闭包的定义为：在函数中能够访问到另一个函数作用域中的变量。闭包在我看来是一种变量的保护机制，由于作用域的关系函数内部的变量无法被外部访问，并且如果函数内部的变量被外部引用那么他在函数结束时不会被垃圾回收，通过这种方法我们可以实现一个不被外界操控的被保护的私有变量，它的原理就是通过划分新的作用域来保护变量不被外界访问

```
闭包是指在一个函数内部定义的函数可以访问该函数作用域内的变量，而这些变量在函数外部是无法访问的。由于闭包可以访问外部函数的变量，因此可以用来创建私有变量和私有方法，实现模块化编程。

闭包的原理是：当函数执行完毕后，其执行上下文会被销毁，其中的变量也会被释放。但是，如果存在闭包，外部函数的执行上下文会被保存在内存中，因为内部函数引用了外部函数的变量，这些变量也会被保存在内存中。这样，即使外部函数执行完毕，内部函数依然可以访问外部函数的变量，因为它们在内存中并没有被释放。

闭包在JavaScript中的应用非常广泛，比如封装私有变量和方法、实现柯里化、异步编程等。需要注意的是，由于闭包会占用内存，如果不恰当地使用闭包，可能会导致内存泄漏等问题，因此在使用闭包时需要注意内存管理。
```



#### 0.1+0.2为什么不等于0.3？

首先IEEE 754对浮点数的计算方式为：小数部分乘2取整，但是小数存储位数存在限制，所以可能存在精度损失，在js中如果要解决这个问题，可以通过Math.abs(0.1+0.2-0.3)<Math.EPSILON来判断

```
0.1+0.2为什么不等于0.3

首先IEEE对浮点数的计算方式为：小数部分乘2取整，但是小数存储位数存在限制，所以可能存在精度损失，在js中如果要解决这个问题，可以通过Math.abs(0.1+0.2-0.3)<Math.EPSILON来判断
```



#### 什么是BFC，BFC有什么作用，如何形成BFC?

BFC是一个独立渲染区域，它定义了BFC区域内标签之前的一些规则，比如兄弟节点都是块级元素，他们之间的margin会进行重叠，子节点margin会影响父节点，浮动元素环绕这些。BFC可以人为的划分，我们可以为其添加特定的属性来划分BFC

```
你的回答基本正确。BFC全称为块级格式化上下文（Block Formatting Context），它是Web页面中的一种CSS渲染模式，是一个独立的渲染区域，具有一定的布局规则和渲染机制。BFC中的元素按照一定的规则进行布局，不会影响到BFC区域外的元素。

BFC的作用主要有三个：

清除浮动：当一个元素设置为BFC后，它的子元素浮动时，不会影响到BFC区域外的元素，同时BFC区域会自动扩展以适应浮动元素的高度，从而避免了父元素高度塌陷的问题。

防止margin重叠：当BFC中相邻的元素的margin发生重叠时，BFC会把它们分开，从而避免了margin重叠的问题。

创建独立的渲染区域：BFC区域内的元素不会影响到外部元素的布局，同时BFC区域也不会受到外部元素的影响，从而可以创建独立的渲染区域。

BFC的形成有多种方式，最常见的方式是通过设置元素的display、position、float、overflow等属性来触发BFC机制。例如，当一个元素设置为float除none以外的值、position除static以外的值、display除inline以外的值、overflow除visible以外的值时，就会形成BFC。此外，还可以通过设置父元素的属性来触发BFC机制，比如父元素设置overflow为hidden或auto时，就可以触发子元素形成BFC。
```



#### 浏览器缓存策略是怎样的？

浏览器的缓存分为强缓存和协商缓存，强缓存优先级高于协商缓存。在第一次请求后，如果响应头中存在cache-control和expires字段，一个返回max-age+秒数，一个返回绝对时间戳，在下一次请求时会根据这两个字段判断请求缓存是否过期，如果还在有效期内则直接从浏览器中读取缓存。如果强缓存未命中，则会进行协商缓存判断，协商缓存顾名思义是要与服务端进行"协商"来判断是否要读取缓存的，第一次请求的响应头中会存在last-modified和Etag字段来记录资源的最后修改时间，而在请求时会加入if-modified-since字段进行协商缓存判断，如果判断资源未被修改，则依然从浏览器缓存中读取请求信息。值得一提的是，last-modifed字段存在时间精度问题，他的精度为秒，如果在一秒钟更改多次，可能会产生误判，Etag相对而言更加智能，他的值是通过计算得出的，不会产生误判

```
浏览器缓存策略主要包括强缓存和协商缓存。

强缓存是通过设置响应头中的Cache-Control和Expires字段来实现的。Cache-Control是HTTP/1.1中的缓存控制字段，常见的取值有max-age和no-cache等。max-age表示缓存的有效期，单位是秒，no-cache表示强制确认缓存是否过期。Expires是HTTP/1.0中的缓存控制字段，其值是一个绝对时间戳，表示缓存的过期时间。如果客户端的请求命中了强缓存，浏览器会直接从缓存中读取资源，不会向服务器发送请求。

协商缓存是通过设置响应头中的Last-Modified和ETag字段来实现的。Last-Modified表示资源的最后修改时间，ETag是一个字符串，表示资源的标识符。当客户端发起请求时，会在请求头中携带If-Modified-Since和If-None-Match字段，分别表示上一次请求返回的Last-Modified和ETag的值。如果服务端判断资源未被修改，则会返回304 Not Modified状态码，客户端会从缓存中读取资源。

需要注意的是，Last-Modified字段存在时间精度问题，精度只能到秒级别，因此在一秒钟内多次修改资源可能会导致缓存失效的误判。而ETag则是通过计算生成的字符串，相对于Last-Modified更加智能。
```



#### 你知道的前端性能优化手段有哪些？

webpack gzip优化，分包splitPlugin，多进程还是多线程打包happypack

图片 懒加载 CDN

浏览器缓存 强缓存 协商缓存

本地存储 保留数据 cookie localStorage sessionStorage

CDN

服务端渲染 SSR 有效降低首屏渲染时间

DOM操作回流重回

防抖节流

前端模块化机制有哪些？

ES Module  Common JS Module，前者通过export导出import导入，后者通过module.exports导出，required导入



#### http2.0做了哪些改进？

二进制协议、多路复用、头部压缩、数据流传输、服务端推送

```
二进制协议：HTTP/2.0使用二进制协议传输数据，取代了HTTP/1.1中的文本协议，因此可以提高传输效率。

多路复用：HTTP/2.0中可以在同一个TCP连接上进行多个请求和响应，不需要像HTTP/1.1一样为每个请求和响应都建立一个TCP连接，因此可以减少建立连接的次数，提高传输效率。

头部压缩：HTTP/2.0使用HPACK算法对请求和响应头部进行压缩，减少了头部的大小，也提高了传输效率。

数据流传输：HTTP/2.0中将请求和响应分割成多个数据流进行传输，可以更加灵活地组合和处理数据，提高传输效率。

服务端推送：HTTP/2.0中支持服务器主动向客户端推送资源，避免了客户端重复请求相同的资源，也提高了传输效率。
```



## 四：



## 五：



## 六：



## 七：



## 八：



## 九：



## 十：

