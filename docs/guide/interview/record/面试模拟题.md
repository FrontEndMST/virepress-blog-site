# 模拟题

## 一：

#### react setState是同步还是异步?

setState是同步代码，但是在React中他的表现像是异步的，原因在于setState在调用后不会立刻更新状态

```
虽然 setState 是同步代码，但在 React 中，它的表现却像是异步的。这是因为在调用 setState 后，React 并不会立即更新状态，而是将该更新推迟到某个合适的时机再执行，这个过程称为“批处理”。

具体来说，当我们调用 setState 时，React 会将该更新加入到一个更新队列中。然后，React 会检查是否有其他更新操作需要执行，如果有，那么它会将所有的更新操作合并成一个更新，然后一次性执行。这个过程可以提高性能，避免了频繁的渲染操作。

当所有的更新操作都完成后，React 会重新渲染组件，并更新组件的状态。在这个过程中，React 会根据更新队列中的操作进行高效的 DOM 操作，以最小化页面的重绘和回流。

需要注意的是，当我们在 setState 中使用回调函数时，回调函数中的代码会在状态更新完成后执行。这是因为 React 会在更新组件状态后，立即执行回调函数，以确保回调函数中使用的状态是最新的。

需要强调的是，虽然 setState 的执行过程看起来像是异步的，但它并不是真正的异步操作，也不会涉及异步回调、Promise 或者异步函数等异步编程方式。因此，在使用 setState 时，我们不需要考虑异步代码的复杂性和不确定性，可以像编写同步代码一样编写 setState 的回调函数。
```



#### 什么是高阶组件，请举例说明?

HOC，他接收一个组件，返回一个新组件，通常有以下几种用法：1.增强props 2.反向继承。增强props很好理解在HOC中为每一个传入的组件附上额外的props，抽离代码逻辑减小耦合。反向继承比较复杂，他通过继承传入组件的方式可以访问到组件中的生命周期和state，并且可以调用父类组件的render函数，通常可以用来控制渲染等。React自身具备的HOC有如React.memo，React Router 中的withRouter也是HOC

```
高阶组件（Higher Order Component，HOC）是一个函数，接收一个组件作为参数，并返回一个新的组件。这个新的组件可以增强或者改变传入的组件的行为。
处理逻辑复用：通过将多个组件共享的逻辑封装在一个 HOC 中，从而减少重复代码的出现。
```



#### 解释一下原型链?

原型链是一种查找机制，当我们访问一个对象中的某个属性时会现在对象内部查找属性，如果没有则会访问prototype，如此反复，这种链式的查找方式就是原型链查找

```
解释一下原型链?

原型链是一种查找机制，当我们访问一个对象中的某个属性时会现在对象内部查找属性，如果没有则会访问prototype，如此反复，这种链式的查找方式就是原型链查找
```



#### instanceof原理?

类在继承时会绑定原型到父类的原型上，所以instanceof的原理就是遍历对象的prototype，如果与类的原型匹配则返回true

```
instanceof 的原理是，它会检查对象的原型链上是否存在类的原型。具体来说，它会沿着对象的 [[Prototype]] 链向上查找，直到找到原型为 null 或者找到与类的原型相同的原型为止。如果找到了与类的原型相同的原型，那么就认为该对象是该类的实例，返回 true；否则返回 false。
```



#### apply和call的作用及区别?

apply和call的作用都是调用函数并修改函数的this为传入的this值，是劫持函数的方法，区别在于apply接收一个参数数组，而call接收多个参数



#### position有哪些值，作用分别是什么?

relative: 相对定位，可以改变在文档流中的位置，以自身左上角为基准点

absolute：绝对定位，脱离文档流，可以改变自身的位置，以最近的定位为非static的父元素

static：默认值，不受left这些属性影响

stricky：在可视范围内时与relative相同，不在时与fixed相同

fixed：固定定位，根据浏览器窗口定位

```
CSS 中的 position 属性用于设置元素的定位方式。它有以下四个可能的值：

static：默认值，元素在文档流中的位置不受 top、right、bottom 和 left 属性的影响，也不能使用 z-index 属性来改变元素的层叠顺序。
relative：元素在文档流中原有的位置不变，但可以通过设置 top、right、bottom 和 left 属性来相对移动元素的位置。如果设置了 z-index 属性，则可以改变元素的层叠顺序。
absolute：元素从文档流中脱离，相对于最近的已定位祖先元素（祖先元素中有一个具有非 static 的 position 值），根据设置的 top、right、bottom 和 left 属性进行绝对定位。如果没有已定位的祖先元素，则相对于文档的初始包含块进行定位。同样可以使用 z-index 属性改变元素的层叠顺序。
fixed：元素相对于浏览器窗口进行定位，即使页面滚动，元素的位置也不会改变。同样可以使用 top、right、bottom 和 left 属性进行定位，也可以使用 z-index 属性改变元素的层叠顺序。
另外，你提到了 sticky 定位，但是这个值并不是 position 属性的取值之一，而是一种相对于滚动容器（例如浏览器窗口或某个元素）进行定位的特殊定位方式。sticky 定位需要设置 top、right、bottom 或 left 属性中的至少一个，表示元素在容器内滚动到某个阈值时开始固定在容器的相应位置，超过另一个阈值时又开始跟随容器滚动。
```



#### 说下你对DOM树的理解?

每一个元素之间存在父子关系和兄弟关系，他们共同构成了一颗DOM树，其中document对象为树的根节点

```
在 HTML 中，所有元素（包括文本节点和注释节点）都可以看作是一棵树上的节点，这棵树就是 DOM 树（Document Object Model Tree）。

DOM 树的根节点是 document 对象，它代表整个 HTML 文档。document 对象下有一个子节点 html，它代表 <html> 元素。html 元素下有两个子节点：head 和 body，分别代表 <head> 和 <body> 元素。依次类推，每个元素下面都可以有任意多个子节点，这些子节点也可以有自己的子节点，从而形成了一棵树形结构。

DOM 树的节点之间有父子关系和兄弟关系。一个节点的父节点是它的直接上级，它的子节点是它的直接下级，而和它同级的节点是它的兄弟节点。在 DOM 树中，任意两个节点之间都存在一条唯一的路径，这条路径由它们之间的父子关系连接而成。

DOM 树的结构对于 JavaScript 操作页面元素非常重要，因为它提供了一种便捷的方式来访问和操作页面中的元素。JavaScript 可以通过访问 DOM 树中的节点来获取页面元素的属性和内容，还可以动态地修改 DOM 树中的节点来改变页面的外观和行为。
```



#### 重排和重绘是什么，有什么区别?

重排也叫回流，通常是对元素的宽高等属性进行了更改，影响了在文档流中的位置，需要浏览器根据新的属性将文档重排，重绘通常是改变了元素的一些样式，需要重新加载元素样式。回流一定触发重绘，但重绘不一定触发回流

```
重排（reflow）和重绘（repaint）是浏览器渲染页面时的两个过程。

重排（也称为回流）是指当浏览器需要重新计算文档的布局信息时，比如修改了元素的尺寸、位置、内容或结构等，就会触发重排。重排会使得浏览器重新计算元素的大小和位置等信息，并重新构建页面的布局树和绘制树，这个过程非常耗费性能。

重绘是指当元素的样式发生变化时，浏览器需要重新绘制元素的外观，但不需要重新计算元素的布局信息。重绘不会影响布局树，而只会更新绘制树中的节点，因此比重排的代价要小得多。

需要注意的是，重排一定会触发重绘，因为元素的几何属性发生变化后必须重新绘制。但重绘不一定会触发重排，因为元素的样式属性发生变化后可能不会影响布局信息。

因此，为了提高页面的性能，我们应该尽量减少重排和重绘的次数。比如可以通过修改样式时尽量使用类名替代直接操作样式、使用文档片段避免频繁修改 DOM 结构等方法来减少重排和重绘的次数。
```



#### https加密过程是怎样的?

http是一个超文本传输协议，而https是加密超文本传输协议，他在应用层和传输层之间新增了一层SSL/TSL用于加密。https中SSL三次握手，以构建安全的https连接，具体是：客户端发送ssl连接请求，内容包括客户端能够接受的CA证书版本和hash算法并发送一个随机数，服务端接收到后返回选择的CA证书和hash算法，并返回一个随机数，客户端验证CA证书有效性后，用客户端公钥加密一个会话密钥发送到服务端，服务端用自己的私钥解密后建立https连接。这个过程中最需要确保的就是服务端发送CA证书和公钥，服务端会采用数字签名的方法保证数据的完整性和安全性

```
HTTPS（Hyper Text Transfer Protocol Secure）是一种通过 SSL/TLS 加密传输数据的 HTTP 协议。它在应用层和传输层之间新增了一层 SSL/TLS 协议，用于加密和验证数据的完整性和安全性。

HTTPS 的加密过程主要包括 SSL 握手和加密通信两个阶段。

在 SSL 握手阶段，客户端和服务端进行三次握手，以建立安全的 HTTPS 连接。具体过程如下：

客户端发送 SSL 连接请求，包括 SSL 版本号、加密算法列表和一个随机数，以及可能需要验证的客户端证书（可选）。
服务端接收到 SSL 连接请求后，回应一个 SSL 连接响应，包括 SSL 版本号、选择的加密算法和一个随机数，以及可能需要验证的服务端证书（可选）。
客户端收到服务端的 SSL 连接响应后，根据服务端的证书验证其有效性，并生成一个用于后续对称加密的会话密钥。客户端用服务端的公钥加密会话密钥，并发送给服务端。
服务端接收到客户端发送的加密的会话密钥后，用自己的私钥解密，获取会话密钥，并生成用于后续对称加密的密钥。服务端用客户端的公钥加密密钥，并发送给客户端。
在加密通信阶段，客户端和服务端使用会话密钥进行对称加密和解密，保证数据的机密性和完整性。

在 HTTPS 连接中，最需要确保的是服务端发送的 CA 证书和公钥的安全性和完整性，服务端会采用数字签名的方法保证数据的可靠性。同时，HTTPS 还可以防止中间人攻击和窃听等安全问题，提供更加安全的网络通信方式。
```



数字签名的过程是什么样？为什么他能保证安全可靠？

```
数字签名是一种对数据进行认证和保护的方法，用于验证数据的完整性和真实性，防止数据被篡改或伪造。数字签名的过程主要包括签名和验证两个步骤。

在签名过程中，发送方使用私钥对数据进行加密，生成数字签名，并将数字签名和原始数据一起传输给接收方。接收方收到数据后，使用发送方的公钥对数字签名进行解密，得到原始数据并验证其完整性和真实性。

数字签名的细节包括：

数字签名使用的是公钥加密和私钥解密的方式，因此发送方需要持有自己的私钥，而接收方需要持有发送方的公钥。
数字签名算法通常包括哈希函数和加密函数两部分。哈希函数用于将原始数据转换为固定长度的摘要，而加密函数用于对摘要进行加密生成数字签名。
数字签名的生成过程需要保证私钥的安全性，防止私钥被泄漏或被攻击者获取，从而导致数字签名失去保护作用。
数字签名的验证过程需要保证公钥的安全性，防止公钥被篡改或被攻击者替换，从而导致验证结果被篡改或伪造。
数字签名算法的选择需要根据安全性和效率的考虑，常见的数字签名算法包括 RSA、DSA 和 ECDSA 等。
总之，数字签名是一种重要的数据保护技术，可以有效地验证数据的完整性和真实性，防止数据被篡改或伪造，保护数据的安全性。
```



#### 为什么数字签名+CA证书能够防止中间人攻击?

```
数字签名和 CA 证书结合使用可以防止中间人攻击，因为数字签名和 CA 证书提供了一种安全的身份验证机制，确保通信双方的身份和数据的完整性，防止中间人篡改或伪造数据。

在数字签名和 CA 证书的过程中，发送方使用私钥对数据进行加密生成数字签名，并使用 CA 证书对数字签名进行认证，确保数字签名的真实性和完整性。接收方使用 CA 证书验证数字签名，并使用发送方的公钥对数字签名进行解密，以确保数据的完整性和真实性。

同时，CA 证书的验证过程也能够防止中间人攻击。在 HTTPS 连接中，服务端会向客户端发送自己的 CA 证书，客户端通过根据自己的信任列表验证 CA 证书的真实性，确保服务端的身份和数据的完整性。如果中间人试图伪造服务端的身份或篡改数据，客户端就会因为无法验证 CA 证书而拒绝连接，从而防止中间人攻击。

因此，数字签名和 CA 证书结合使用可以提供一种安全的身份验证机制，确保通信双方的身份和数据的完整性，防止中间人攻击，保护网络通信的安全性。
```



## 二：



## 三：

#### react合成事件是什么，和原生事件的区别？

react合成事件是react内部实现的事件处理系统，相比于原生事件系统做了诸多优化。比如更好的性能，合成事件采用了事件池设计，event对象不会被销毁，可以重复使用，减小了开销。其次在合成事件中可以自定义event对象的属性，方便我们更好的扩展

```
首先，React合成事件是基于浏览器原生事件机制实现的，但是React会在事件冒泡阶段对原生事件进行包装，形成一个合成事件对象，来统一处理不同浏览器之间的差异。

其次，React合成事件与原生事件的主要区别在于性能和处理方式上。React合成事件采用了事件池技术，可以重用事件对象，减少内存开销，提高性能。此外，React合成事件对事件处理方式进行了优化，例如对于一些事件处理函数会进行批量更新，避免频繁的重新渲染。

最后，React合成事件还提供了一些其他的扩展功能，例如可拖拽、可复制、可粘贴等。在React开发中，一般推荐使用React合成事件来处理用户交互事件，因为它比原生事件更高效、更易用、更可靠。
```



#### react如何处理异常？

react的异常处理通常在类式组件中，可以通过componentDidCatch和should...的两个API对错误进行捕获，他们仅能捕获react所产生的错误，像ErrorBoundery这样捕获下层组件产生错误，ErrorBoundery的设计通过捕获底层组件抛出的Promise实现错误捕获，如果要捕获代码中的错误还是应该使用trycatch

```
在React中，可以通过错误边界（Error Boundaries）机制来捕获和处理组件渲染过程中的异常。错误边界是一种React组件，它可以在其子组件中捕获并处理错误，防止错误的传播影响整个应用的正常运行。

在类组件中，可以使用componentDidCatch()方法来捕获子组件中的错误。当子组件发生错误时，componentDidCatch()方法会被调用，可以在该方法中进行错误的处理、记录或反馈等操作。需要注意的是，componentDidCatch()只能捕获子组件中的错误，而无法捕获在事件处理函数、异步操作和服务端渲染等场景中产生的错误。

另外，React还提供了shouldComponentUpdate()方法来控制组件是否重新渲染。可以在该方法中对组件的状态和属性进行比较，来决定是否需要重新渲染组件。这样可以有效减少组件的渲染次数，提高应用的性能。

需要注意的是，React的错误边界机制并不能完全避免应用的崩溃或异常，因此在开发过程中，还需要注意编写健壮性高的代码，以避免出现意外的错误。
```



#### 闭包的作用和原理？

闭包的定义为：在函数中能够访问到另一个函数作用域中的变量。闭包在我看来是一种变量的保护机制，由于作用域的关系函数内部的变量无法被外部访问，并且如果函数内部的变量被外部引用那么他在函数结束时不会被垃圾回收，通过这种方法我们可以实现一个不被外界操控的被保护的私有变量，它的原理就是通过划分新的作用域来保护变量不被外界访问

```
闭包是指在一个函数内部定义的函数可以访问该函数作用域内的变量，而这些变量在函数外部是无法访问的。由于闭包可以访问外部函数的变量，因此可以用来创建私有变量和私有方法，实现模块化编程。

闭包的原理是：当函数执行完毕后，其执行上下文会被销毁，其中的变量也会被释放。但是，如果存在闭包，外部函数的执行上下文会被保存在内存中，因为内部函数引用了外部函数的变量，这些变量也会被保存在内存中。这样，即使外部函数执行完毕，内部函数依然可以访问外部函数的变量，因为它们在内存中并没有被释放。

闭包在JavaScript中的应用非常广泛，比如封装私有变量和方法、实现柯里化、异步编程等。需要注意的是，由于闭包会占用内存，如果不恰当地使用闭包，可能会导致内存泄漏等问题，因此在使用闭包时需要注意内存管理。
```



#### 0.1+0.2为什么不等于0.3？

首先IEEE 754对浮点数的计算方式为：小数部分乘2取整，但是小数存储位数存在限制，所以可能存在精度损失，在js中如果要解决这个问题，可以通过Math.abs(0.1+0.2-0.3)<Math.EPSILON来判断

```
0.1+0.2为什么不等于0.3

首先IEEE对浮点数的计算方式为：小数部分乘2取整，但是小数存储位数存在限制，所以可能存在精度损失，在js中如果要解决这个问题，可以通过Math.abs(0.1+0.2-0.3)<Math.EPSILON来判断
```



#### 什么是BFC，BFC有什么作用，如何形成BFC?

BFC是一个独立渲染区域，它定义了BFC区域内标签之前的一些规则，比如兄弟节点都是块级元素，他们之间的margin会进行重叠，子节点margin会影响父节点，浮动元素环绕这些。BFC可以人为的划分，我们可以为其添加特定的属性来划分BFC

```
你的回答基本正确。BFC全称为块级格式化上下文（Block Formatting Context），它是Web页面中的一种CSS渲染模式，是一个独立的渲染区域，具有一定的布局规则和渲染机制。BFC中的元素按照一定的规则进行布局，不会影响到BFC区域外的元素。

BFC的作用主要有三个：

清除浮动：当一个元素设置为BFC后，它的子元素浮动时，不会影响到BFC区域外的元素，同时BFC区域会自动扩展以适应浮动元素的高度，从而避免了父元素高度塌陷的问题。

防止margin重叠：当BFC中相邻的元素的margin发生重叠时，BFC会把它们分开，从而避免了margin重叠的问题。

创建独立的渲染区域：BFC区域内的元素不会影响到外部元素的布局，同时BFC区域也不会受到外部元素的影响，从而可以创建独立的渲染区域。

BFC的形成有多种方式，最常见的方式是通过设置元素的display、position、float、overflow等属性来触发BFC机制。例如，当一个元素设置为float除none以外的值、position除static以外的值、display除inline以外的值、overflow除visible以外的值时，就会形成BFC。此外，还可以通过设置父元素的属性来触发BFC机制，比如父元素设置overflow为hidden或auto时，就可以触发子元素形成BFC。
```



#### 浏览器缓存策略是怎样的？

浏览器的缓存分为强缓存和协商缓存，强缓存优先级高于协商缓存。在第一次请求后，如果响应头中存在cache-control和expires字段，一个返回max-age+秒数，一个返回绝对时间戳，在下一次请求时会根据这两个字段判断请求缓存是否过期，如果还在有效期内则直接从浏览器中读取缓存。如果强缓存未命中，则会进行协商缓存判断，协商缓存顾名思义是要与服务端进行"协商"来判断是否要读取缓存的，第一次请求的响应头中会存在last-modified和Etag字段来记录资源的最后修改时间，而在请求时会加入if-modified-since字段进行协商缓存判断，如果判断资源未被修改，则依然从浏览器缓存中读取请求信息。值得一提的是，last-modifed字段存在时间精度问题，他的精度为秒，如果在一秒钟更改多次，可能会产生误判，Etag相对而言更加智能，他的值是通过计算得出的，不会产生误判

```
浏览器缓存策略主要包括强缓存和协商缓存。

强缓存是通过设置响应头中的Cache-Control和Expires字段来实现的。Cache-Control是HTTP/1.1中的缓存控制字段，常见的取值有max-age和no-cache等。max-age表示缓存的有效期，单位是秒，no-cache表示强制确认缓存是否过期。Expires是HTTP/1.0中的缓存控制字段，其值是一个绝对时间戳，表示缓存的过期时间。如果客户端的请求命中了强缓存，浏览器会直接从缓存中读取资源，不会向服务器发送请求。

协商缓存是通过设置响应头中的Last-Modified和ETag字段来实现的。Last-Modified表示资源的最后修改时间，ETag是一个字符串，表示资源的标识符。当客户端发起请求时，会在请求头中携带If-Modified-Since和If-None-Match字段，分别表示上一次请求返回的Last-Modified和ETag的值。如果服务端判断资源未被修改，则会返回304 Not Modified状态码，客户端会从缓存中读取资源。

需要注意的是，Last-Modified字段存在时间精度问题，精度只能到秒级别，因此在一秒钟内多次修改资源可能会导致缓存失效的误判。而ETag则是通过计算生成的字符串，相对于Last-Modified更加智能。
```



#### 你知道的前端性能优化手段有哪些？

webpack gzip优化，分包splitPlugin，多进程还是多线程打包happypack

图片 懒加载 CDN

浏览器缓存 强缓存 协商缓存

本地存储 保留数据 cookie localStorage sessionStorage

CDN

服务端渲染 SSR 有效降低首屏渲染时间

DOM操作回流重回

防抖节流

前端模块化机制有哪些？

ES Module  Common JS Module，前者通过export导出import导入，后者通过module.exports导出，required导入



#### http2.0做了哪些改进？

二进制协议、多路复用、头部压缩、数据流传输、服务端推送

```
二进制协议：HTTP/2.0使用二进制协议传输数据，取代了HTTP/1.1中的文本协议，因此可以提高传输效率。

多路复用：HTTP/2.0中可以在同一个TCP连接上进行多个请求和响应，不需要像HTTP/1.1一样为每个请求和响应都建立一个TCP连接，因此可以减少建立连接的次数，提高传输效率。

头部压缩：HTTP/2.0使用HPACK算法对请求和响应头部进行压缩，减少了头部的大小，也提高了传输效率。

数据流传输：HTTP/2.0中将请求和响应分割成多个数据流进行传输，可以更加灵活地组合和处理数据，提高传输效率。

服务端推送：HTTP/2.0中支持服务器主动向客户端推送资源，避免了客户端重复请求相同的资源，也提高了传输效率。
```



## 四：



## 五：



## 六：



## 七：



## 八：



## 九：



## 十：

