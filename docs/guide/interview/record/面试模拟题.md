# 模拟题

## 一：75

#### react setState是同步还是异步?

setState是同步代码，但是在React中他的表现像是异步的，原因在于setState在调用后不会立刻更新状态

```
虽然 setState 是同步代码，但在 React 中，它的表现却像是异步的。这是因为在调用 setState 后，React 并不会立即更新状态，而是将该更新推迟到某个合适的时机再执行，这个过程称为“批处理”。

具体来说，当我们调用 setState 时，React 会将该更新加入到一个更新队列中。然后，React 会检查是否有其他更新操作需要执行，如果有，那么它会将所有的更新操作合并成一个更新，然后一次性执行。这个过程可以提高性能，避免了频繁的渲染操作。

当所有的更新操作都完成后，React 会重新渲染组件，并更新组件的状态。在这个过程中，React 会根据更新队列中的操作进行高效的 DOM 操作，以最小化页面的重绘和回流。

需要注意的是，当我们在 setState 中使用回调函数时，回调函数中的代码会在状态更新完成后执行。这是因为 React 会在更新组件状态后，立即执行回调函数，以确保回调函数中使用的状态是最新的。

需要强调的是，虽然 setState 的执行过程看起来像是异步的，但它并不是真正的异步操作，也不会涉及异步回调、Promise 或者异步函数等异步编程方式。因此，在使用 setState 时，我们不需要考虑异步代码的复杂性和不确定性，可以像编写同步代码一样编写 setState 的回调函数。
```



#### 什么是高阶组件，请举例说明?

HOC，他接收一个组件，返回一个新组件，通常有以下几种用法：1.增强props 2.反向继承。增强props很好理解在HOC中为每一个传入的组件附上额外的props，抽离代码逻辑减小耦合。反向继承比较复杂，他通过继承传入组件的方式可以访问到组件中的生命周期和state，并且可以调用父类组件的render函数，通常可以用来控制渲染等。React自身具备的HOC有如React.memo，React Router 中的withRouter也是HOC

```
高阶组件（Higher Order Component，HOC）是一个函数，接收一个组件作为参数，并返回一个新的组件。这个新的组件可以增强或者改变传入的组件的行为。
增强组件的功能：通过给组件传入额外的 props，或者重写组件的某些方法，从而增强组件的功能。
处理逻辑复用：通过将多个组件共享的逻辑封装在一个 HOC 中，从而减少重复代码的出现。
```



#### 解释一下原型链?

原型链是一种查找机制，当我们访问一个对象中的某个属性时会现在对象内部查找属性，如果没有则会访问prototype，如此反复，这种链式的查找方式就是原型链查找

```
在 JavaScript 中，每个对象都有一个内部属性 [[Prototype]]，它指向它的原型对象（或者说是它的构造函数的 prototype 属性）。如果我们访问一个对象中的某个属性，但该属性在对象本身上不存在，那么 JavaScript 引擎会沿着对象的原型链向上查找，直到找到该属性或者到达原型链的末尾（即 null）为止。
```



#### instanceof原理?

类在继承时会绑定原型到父类的原型上，所以instanceof的原理就是遍历对象的prototype，如果与类的原型匹配则返回true

```
instanceof 的原理是，它会检查对象的原型链上是否存在类的原型。具体来说，它会沿着对象的 [[Prototype]] 链向上查找，直到找到原型为 null 或者找到与类的原型相同的原型为止。如果找到了与类的原型相同的原型，那么就认为该对象是该类的实例，返回 true；否则返回 false。
```



#### apply和call的作用及区别?

apply和call的作用都是调用函数并修改函数的this为传入的this值，是劫持函数的方法，区别在于apply接收一个参数数组，而call接收多个参数



#### position有哪些值，作用分别是什么?

relative: 相对定位，可以改变在文档流中的位置，以自身左上角为基准点

absolute：绝对定位，脱离文档流，可以改变自身的位置，以最近的定位为非static的父元素

static：默认值，不受left这些属性影响

stricky：在可视范围内时与relative相同，不在时与fixed相同

fixed：固定定位，根据浏览器窗口定位

```
CSS 中的 position 属性用于设置元素的定位方式。它有以下四个可能的值：

static：默认值，元素在文档流中的位置不受 top、right、bottom 和 left 属性的影响，也不能使用 z-index 属性来改变元素的层叠顺序。
relative：元素在文档流中原有的位置不变，但可以通过设置 top、right、bottom 和 left 属性来相对移动元素的位置。如果设置了 z-index 属性，则可以改变元素的层叠顺序。
absolute：元素从文档流中脱离，相对于最近的已定位祖先元素（祖先元素中有一个具有非 static 的 position 值），根据设置的 top、right、bottom 和 left 属性进行绝对定位。如果没有已定位的祖先元素，则相对于文档的初始包含块进行定位。同样可以使用 z-index 属性改变元素的层叠顺序。
fixed：元素相对于浏览器窗口进行定位，即使页面滚动，元素的位置也不会改变。同样可以使用 top、right、bottom 和 left 属性进行定位，也可以使用 z-index 属性改变元素的层叠顺序。
另外，你提到了 sticky 定位，但是这个值并不是 position 属性的取值之一，而是一种相对于滚动容器（例如浏览器窗口或某个元素）进行定位的特殊定位方式。sticky 定位需要设置 top、right、bottom 或 left 属性中的至少一个，表示元素在容器内滚动到某个阈值时开始固定在容器的相应位置，超过另一个阈值时又开始跟随容器滚动。
```



#### 说下你对DOM树的理解?

每一个元素之间存在父子关系和兄弟关系，他们共同构成了一颗DOM树，其中document对象为树的根节点

```
在 HTML 中，所有元素（包括文本节点和注释节点）都可以看作是一棵树上的节点，这棵树就是 DOM 树（Document Object Model Tree）。

DOM 树的根节点是 document 对象，它代表整个 HTML 文档。document 对象下有一个子节点 html，它代表 <html> 元素。html 元素下有两个子节点：head 和 body，分别代表 <head> 和 <body> 元素。依次类推，每个元素下面都可以有任意多个子节点，这些子节点也可以有自己的子节点，从而形成了一棵树形结构。

DOM 树的节点之间有父子关系和兄弟关系。一个节点的父节点是它的直接上级，它的子节点是它的直接下级，而和它同级的节点是它的兄弟节点。在 DOM 树中，任意两个节点之间都存在一条唯一的路径，这条路径由它们之间的父子关系连接而成。

DOM 树的结构对于 JavaScript 操作页面元素非常重要，因为它提供了一种便捷的方式来访问和操作页面中的元素。JavaScript 可以通过访问 DOM 树中的节点来获取页面元素的属性和内容，还可以动态地修改 DOM 树中的节点来改变页面的外观和行为。
```



#### 重排和重绘是什么，有什么区别?

重排也叫回流，通常是对元素的宽高等属性进行了更改，影响了在文档流中的位置，需要浏览器根据新的属性将文档重排，重绘通常是改变了元素的一些样式，需要重新加载元素样式。回流一定触发重绘，但重绘不一定触发回流

```
重排（reflow）和重绘（repaint）是浏览器渲染页面时的两个过程。

重排（也称为回流）是指当浏览器需要重新计算文档的布局信息时，比如修改了元素的尺寸、位置、内容或结构等，就会触发重排。重排会使得浏览器重新计算元素的大小和位置等信息，并重新构建页面的布局树和绘制树，这个过程非常耗费性能。

重绘是指当元素的样式发生变化时，浏览器需要重新绘制元素的外观，但不需要重新计算元素的布局信息。重绘不会影响布局树，而只会更新绘制树中的节点，因此比重排的代价要小得多。

需要注意的是，重排一定会触发重绘，因为元素的几何属性发生变化后必须重新绘制。但重绘不一定会触发重排，因为元素的样式属性发生变化后可能不会影响布局信息。

因此，为了提高页面的性能，我们应该尽量减少重排和重绘的次数。比如可以通过修改样式时尽量使用类名替代直接操作样式、使用文档片段避免频繁修改 DOM 结构等方法来减少重排和重绘的次数。
```



#### https加密过程是怎样的?

http是一个超文本传输协议，而https是加密超文本传输协议，他在应用层和传输层之间新增了一层SSL/TSL用于加密。https中SSL三次握手，以构建安全的https连接，具体是：客户端发送ssl连接请求，内容包括客户端能够接受的CA证书版本和hash算法并发送一个随机数，服务端接收到后返回选择的CA证书和hash算法，并返回一个随机数，客户端验证CA证书有效性后，用客户端公钥加密一个会话密钥发送到服务端，服务端用自己的私钥解密后建立https连接。这个过程中最需要确保的就是服务端发送CA证书和公钥，服务端会采用数字签名的方法保证数据的完整性和安全性

```
HTTPS（Hyper Text Transfer Protocol Secure）是一种通过 SSL/TLS 加密传输数据的 HTTP 协议。它在应用层和传输层之间新增了一层 SSL/TLS 协议，用于加密和验证数据的完整性和安全性。

HTTPS 的加密过程主要包括 SSL 握手和加密通信两个阶段。

在 SSL 握手阶段，客户端和服务端进行三次握手，以建立安全的 HTTPS 连接。具体过程如下：

客户端发送 SSL 连接请求，包括 SSL 版本号、加密算法列表和一个随机数，以及可能需要验证的客户端证书（可选）。
服务端接收到 SSL 连接请求后，回应一个 SSL 连接响应，包括 SSL 版本号、选择的加密算法和一个随机数，以及可能需要验证的服务端证书（可选）。
客户端收到服务端的 SSL 连接响应后，根据服务端的证书验证其有效性，并生成一个用于后续对称加密的会话密钥。客户端用服务端的公钥加密会话密钥，并发送给服务端。
服务端接收到客户端发送的加密的会话密钥后，用自己的私钥解密，获取会话密钥，并生成用于后续对称加密的密钥。服务端用客户端的公钥加密密钥，并发送给客户端。
在加密通信阶段，客户端和服务端使用会话密钥进行对称加密和解密，保证数据的机密性和完整性。

在 HTTPS 连接中，最需要确保的是服务端发送的 CA 证书和公钥的安全性和完整性，服务端会采用数字签名的方法保证数据的可靠性。同时，HTTPS 还可以防止中间人攻击和窃听等安全问题，提供更加安全的网络通信方式。
```



数字签名的过程是什么样？为什么他能保证安全可靠？

```
数字签名是一种对数据进行认证和保护的方法，用于验证数据的完整性和真实性，防止数据被篡改或伪造。数字签名的过程主要包括签名和验证两个步骤。

在签名过程中，发送方使用私钥对数据进行加密，生成数字签名，并将数字签名和原始数据一起传输给接收方。接收方收到数据后，使用发送方的公钥对数字签名进行解密，得到原始数据并验证其完整性和真实性。

数字签名的细节包括：

数字签名使用的是公钥加密和私钥解密的方式，因此发送方需要持有自己的私钥，而接收方需要持有发送方的公钥。
数字签名算法通常包括哈希函数和加密函数两部分。哈希函数用于将原始数据转换为固定长度的摘要，而加密函数用于对摘要进行加密生成数字签名。
数字签名的生成过程需要保证私钥的安全性，防止私钥被泄漏或被攻击者获取，从而导致数字签名失去保护作用。
数字签名的验证过程需要保证公钥的安全性，防止公钥被篡改或被攻击者替换，从而导致验证结果被篡改或伪造。
数字签名算法的选择需要根据安全性和效率的考虑，常见的数字签名算法包括 RSA、DSA 和 ECDSA 等。
总之，数字签名是一种重要的数据保护技术，可以有效地验证数据的完整性和真实性，防止数据被篡改或伪造，保护数据的安全性。
```



#### 为什么数字签名+CA证书能够防止中间人攻击?

```
数字签名和 CA 证书结合使用可以防止中间人攻击，因为数字签名和 CA 证书提供了一种安全的身份验证机制，确保通信双方的身份和数据的完整性，防止中间人篡改或伪造数据。

在数字签名和 CA 证书的过程中，发送方使用私钥对数据进行加密生成数字签名，并使用 CA 证书对数字签名进行认证，确保数字签名的真实性和完整性。接收方使用 CA 证书验证数字签名，并使用发送方的公钥对数字签名进行解密，以确保数据的完整性和真实性。

同时，CA 证书的验证过程也能够防止中间人攻击。在 HTTPS 连接中，服务端会向客户端发送自己的 CA 证书，客户端通过根据自己的信任列表验证 CA 证书的真实性，确保服务端的身份和数据的完整性。如果中间人试图伪造服务端的身份或篡改数据，客户端就会因为无法验证 CA 证书而拒绝连接，从而防止中间人攻击。

因此，数字签名和 CA 证书结合使用可以提供一种安全的身份验证机制，确保通信双方的身份和数据的完整性，防止中间人攻击，保护网络通信的安全性。
```



## 二：60

#### react为什么需要合成事件？

react如果不使用合成事件，那就只能调用原生的事件，所以接下来我将阐述的是react合成事件相较于原生事件的优点：1.react合成事件可以自定义event对象 2.合成事件底层采用事件池设计，事件对象可以重复使用，减小了开销 3.react合成事件拥有更好的跨平台兼容性，并且更好统一管理

```
React 合成事件的优点包括：

自定义 event 对象：React 合成事件将所有浏览器的事件都统一封装成了一个合成事件对象，这个对象可以在不同浏览器和平台下保持一致，同时还可以添加自定义属性和方法。

事件池设计：React 合成事件底层采用了事件池的设计，即在事件触发后，合成事件对象会被重置并放回到事件池中，下次再触发同类型事件时可以直接复用，避免了频繁创建和销毁大量的事件对象，减小了内存开销。

跨平台兼容性：React 合成事件可以在不同平台和浏览器中保持一致，以及更好地管理事件的处理和传递，避免了平台差异性带来的问题，提高了开发效率。
```



#### 为什么有时react两次setState，只执行一次

react的setState方法是同步调用，但是由于其特殊的执行时期，导致他呈现异步的效果，这个时期就是react的批处理，react对于多个setState调用，会放入一个队列中，并且根据isBatchingUpdates字段来判断是否要进行setState合并操作，也就是批处理过程，如果为true，则将多个setState进行合并，所以只调用一次

```
React 的 setState 方法是同步调用的，但是它的更新并不是立即执行的，而是被批量处理的，这个批量处理的过程会将多次 setState 调用合并成一次，以提高渲染性能和优化用户体验。

React 内部使用了一个叫做“事务”的机制来实现这个批量处理的过程，它会在一些特定的场景中自动启用，如在 React 生命周期函数、React 事件处理函数、React 异步更新等情况下。

当我们在 React 生命周期函数中调用 setState 方法时，React 会自动将这些调用合并成一次更新操作，在下一个更新周期统一进行处理。这个更新周期有一个名字叫做“批量更新模式”，它的具体实现是通过一个叫做“事务队列”的机制来实现的。

在批量更新模式中，React 会将多个 setState 调用放到一个队列里，等到下一个更新周期再进行处理。如果在同一个更新周期内多次调用 setState，React 会合并这些调用，只进行一次更新操作，从而提高性能。

因此，有时候我们在调用 setState 方法时，可能会看到只有一次更新操作被执行，即使我们多次调用了 setState。这是因为 React 内部自动启用了批量更新模式，将多次更新操作合并成了一次，从而提高了性能。
```



#### redux有哪些原则？

```
Redux 的三个核心原则分别是：单一数据源、状态只读、使用纯函数来执行修改。

单一数据源：Redux 应用中的状态数据应该只存储在唯一的 store 中，而不是分散在多个组件或者对象中。这样可以确保状态的一致性和可预测性。

状态只读：Redux 中的状态是只读的，不能直接修改，只能通过 dispatch 来触发对应的 action，由 reducer 来修改状态。这样可以避免状态被误修改，同时也方便跟踪状态的变化。

使用纯函数来执行修改：Redux 中的 reducer 必须是一个纯函数，接收旧的状态和 action，返回新的状态。这样可以确保修改状态的过程是可预测和可追溯的。
```



#### es5实现继承

es5的继承方式有多种：原型链继承，借用构造函数继承，原型式继承，寄生式继承，组合式继承，寄生组合式继承等。可能有缺漏的，实现我就不细讲了



#### CSS选择器有哪些？

```
元素选择器：通过元素名来选择元素，如 div、p、ul 等。

ID 选择器：通过元素的 ID 属性来选择元素，如 #myId。

类选择器：通过元素的 class 属性来选择元素，如 .myClass。

属性选择器：通过元素的属性来选择元素，如 [title]、[href="https://www.example.com"] 等。

通配符选择器：选择所有元素，如 *。

组合选择器：将多个选择器组合在一起，如 .myClass p、div.myClass 等。

后代选择器：选择某个元素的后代元素，如 div p、ul li 等。

子选择器：选择某个元素的直接子元素，如 ul > li。

相邻兄弟选择器：选择紧接在某个元素后面的相邻元素，如 h1 + p。

兄弟选择器：选择某个元素后面的所有兄弟元素，如 h1 ~ p。

伪类选择器：选择元素的特定状态，如 :hover、:active、:visited 等。

伪元素选择器：选择元素的某个虚拟部分，如 ::before、::after、::first-line 等。
```



说下事件模型

DOM事件触发主要分为三个阶段：捕获阶段 处于目标阶段 冒泡阶段。通常添加事件监听器时可以传入第三个参数，默认为false冒泡阶段，true则为捕获阶段。并且可以在某一层冒泡上通过event.stopPropergation停止冒泡过程

```
说下事件模型

DOM事件触发主要分为三个阶段：捕获阶段 处于目标阶段 冒泡阶段。通常添加事件监听器时可以传入第三个参数，默认为false冒泡阶段，true则为捕获阶段。并且可以在某一层冒泡上通过event.stopPropergation停止冒泡过程
```

如何减少白屏的时间

SSR服务端渲染，降低js文件大小，合理的webpack分包策略等

```
服务器端渲染（SSR）：使用服务器端渲染可以在服务器端生成 HTML 内容，从而减少客户端加载和渲染的时间，从而减少白屏时间。

按需加载：对于一些不必要的资源，例如图片、CSS 和 JavaScript 文件等，可以采用按需加载的方式，只有当需要使用时才加载，可以使用懒加载、预加载等技术。

合理的代码分割：将代码分割成多个小的模块，然后按需加载，可以减少首屏加载时需要下载的 JavaScript 文件大小，从而减少白屏时间。

压缩和缓存：使用 Gzip 等压缩技术可以减少文件大小，从而提高加载速度，同时使用浏览器缓存可以减少重复下载的次数。

使用 CDN：使用 CDN 可以将资源分布到多个服务器上，从而提高资源的访问速度和下载速度。

减少 HTTP 请求：减少页面中的 HTTP 请求可以减少加载时间，可以通过合并 JavaScript 和 CSS 文件、使用精灵图等方式来实现。

预加载：对于一些重要但不会立即使用的资源，例如图片等，可以使用预加载的方式，在页面加载完成后预先加载这些资源，从而提高后续使用时的速度。
```

#### TCP3次握手过程

客户端发送建立连接报文，并发送SYN，进入SYN-SEND状态，服务端接收到SYN后进入listen状态，然后发送确认连接报文，进入SYN-RECV状态，客户端接收到服务端确认连接报文后建立连接，进入establish状态，向服务端发送确认报文，服务端接收到连报文也进入establish状态

```
客户端发送SYN报文：客户端向服务器端发送一个SYN报文，其中SYN标志位被设置为1，表示客户端请求建立连接。同时，客户端会随机生成一个初始序列号（ISN）作为第一个数据包的序列号。

服务端发送SYN+ACK报文：服务器端收到客户端的SYN报文后，如果同意建立连接，则向客户端发送一个SYN+ACK报文。其中SYN标志位被设置为1，表示服务器端同意建立连接；ACK标志位被设置为1，表示服务器端已经收到客户端的SYN报文；同时，服务器端也会随机生成一个初始序列号作为第一个数据包的序列号。

客户端发送ACK报文：客户端收到服务器端的SYN+ACK报文后，向服务器端发送一个ACK报文，其中ACK标志位被设置为1，表示客户端已经收到服务器端的SYN+ACK报文，并确认建立连接。同时，客户端也会把服务器端的初始序列号加1作为第一个数据包的序列号。
```



## 三：70

#### react合成事件是什么，和原生事件的区别？

react合成事件是react内部实现的事件处理系统，相比于原生事件系统做了诸多优化。比如更好的性能，合成事件采用了事件池设计，event对象不会被销毁，可以重复使用，减小了开销。其次在合成事件中可以自定义event对象的属性，方便我们更好的扩展

```
首先，React合成事件是基于浏览器原生事件机制实现的，但是React会在事件冒泡阶段对原生事件进行包装，形成一个合成事件对象，来统一处理不同浏览器之间的差异。

其次，React合成事件与原生事件的主要区别在于性能和处理方式上。React合成事件采用了事件池技术，可以重用事件对象，减少内存开销，提高性能。此外，React合成事件对事件处理方式进行了优化，例如对于一些事件处理函数会进行批量更新，避免频繁的重新渲染。

最后，React合成事件还提供了一些其他的扩展功能，例如可拖拽、可复制、可粘贴等。在React开发中，一般推荐使用React合成事件来处理用户交互事件，因为它比原生事件更高效、更易用、更可靠。
```



#### react如何处理异常？

react的异常处理通常在类式组件中，可以通过componentDidCatch和should...的两个API对错误进行捕获，他们仅能捕获react所产生的错误，像ErrorBoundery这样捕获下层组件产生错误，ErrorBoundery的设计通过捕获底层组件抛出的Promise实现错误捕获，如果要捕获代码中的错误还是应该使用trycatch

```
在React中，可以通过错误边界（Error Boundaries）机制来捕获和处理组件渲染过程中的异常。错误边界是一种React组件，它可以在其子组件中捕获并处理错误，防止错误的传播影响整个应用的正常运行。

在类组件中，可以使用componentDidCatch()方法来捕获子组件中的错误。当子组件发生错误时，componentDidCatch()方法会被调用，可以在该方法中进行错误的处理、记录或反馈等操作。需要注意的是，componentDidCatch()只能捕获子组件中的错误，而无法捕获在事件处理函数、异步操作和服务端渲染等场景中产生的错误。

另外，React还提供了shouldComponentUpdate()方法来控制组件是否重新渲染。可以在该方法中对组件的状态和属性进行比较，来决定是否需要重新渲染组件。这样可以有效减少组件的渲染次数，提高应用的性能。

需要注意的是，React的错误边界机制并不能完全避免应用的崩溃或异常，因此在开发过程中，还需要注意编写健壮性高的代码，以避免出现意外的错误。
```



#### 闭包的作用和原理？

闭包的定义为：在函数中能够访问到另一个函数作用域中的变量。闭包在我看来是一种变量的保护机制，由于作用域的关系函数内部的变量无法被外部访问，并且如果函数内部的变量被外部引用那么他在函数结束时不会被垃圾回收，通过这种方法我们可以实现一个不被外界操控的被保护的私有变量，它的原理就是通过划分新的作用域来保护变量不被外界访问

```
闭包是指在一个函数内部定义的函数可以访问该函数作用域内的变量，而这些变量在函数外部是无法访问的。由于闭包可以访问外部函数的变量，因此可以用来创建私有变量和私有方法，实现模块化编程。

闭包的原理是：当函数执行完毕后，其执行上下文会被销毁，其中的变量也会被释放。但是，如果存在闭包，外部函数的执行上下文会被保存在内存中，因为内部函数引用了外部函数的变量，这些变量也会被保存在内存中。这样，即使外部函数执行完毕，内部函数依然可以访问外部函数的变量，因为它们在内存中并没有被释放。

闭包在JavaScript中的应用非常广泛，比如封装私有变量和方法、实现柯里化、异步编程等。需要注意的是，由于闭包会占用内存，如果不恰当地使用闭包，可能会导致内存泄漏等问题，因此在使用闭包时需要注意内存管理。
```



#### 0.1+0.2为什么不等于0.3？

首先IEEE 754对浮点数的计算方式为：小数部分乘2取整，但是小数存储位数存在限制，所以可能存在精度损失，在js中如果要解决这个问题，可以通过Math.abs(0.1+0.2-0.3)<Math.EPSILON来判断

```
0.1+0.2为什么不等于0.3

首先IEEE对浮点数的计算方式为：小数部分乘2取整，但是小数存储位数存在限制，所以可能存在精度损失，在js中如果要解决这个问题，可以通过Math.abs(0.1+0.2-0.3)<Math.EPSILON来判断
```



#### 什么是BFC，BFC有什么作用，如何形成BFC?

BFC是一个独立渲染区域，它定义了BFC区域内标签之前的一些规则，比如兄弟节点都是块级元素，他们之间的margin会进行重叠，子节点margin会影响父节点，浮动元素环绕这些。BFC可以人为的划分，我们可以为其添加特定的属性来划分BFC

```
你的回答基本正确。BFC全称为块级格式化上下文（Block Formatting Context），它是Web页面中的一种CSS渲染模式，是一个独立的渲染区域，具有一定的布局规则和渲染机制。BFC中的元素按照一定的规则进行布局，不会影响到BFC区域外的元素。

BFC的作用主要有三个：

清除浮动：当一个元素设置为BFC后，它的子元素浮动时，不会影响到BFC区域外的元素，同时BFC区域会自动扩展以适应浮动元素的高度，从而避免了父元素高度塌陷的问题。

防止margin重叠：当BFC中相邻的元素的margin发生重叠时，BFC会把它们分开，从而避免了margin重叠的问题。

创建独立的渲染区域：BFC区域内的元素不会影响到外部元素的布局，同时BFC区域也不会受到外部元素的影响，从而可以创建独立的渲染区域。

BFC的形成有多种方式，最常见的方式是通过设置元素的display、position、float、overflow等属性来触发BFC机制。例如，当一个元素设置为float除none以外的值、position除static以外的值、display除inline以外的值、overflow除visible以外的值时，就会形成BFC。此外，还可以通过设置父元素的属性来触发BFC机制，比如父元素设置overflow为hidden或auto时，就可以触发子元素形成BFC。
```



#### 浏览器缓存策略是怎样的？

浏览器的缓存分为强缓存和协商缓存，强缓存优先级高于协商缓存。在第一次请求后，如果响应头中存在cache-control和expires字段，一个返回max-age+秒数，一个返回绝对时间戳，在下一次请求时会根据这两个字段判断请求缓存是否过期，如果还在有效期内则直接从浏览器中读取缓存。如果强缓存未命中，则会进行协商缓存判断，协商缓存顾名思义是要与服务端进行"协商"来判断是否要读取缓存的，第一次请求的响应头中会存在last-modified和Etag字段来记录资源的最后修改时间，而在请求时会加入if-modified-since字段进行协商缓存判断，如果判断资源未被修改，则依然从浏览器缓存中读取请求信息。值得一提的是，last-modifed字段存在时间精度问题，他的精度为秒，如果在一秒钟更改多次，可能会产生误判，Etag相对而言更加智能，他的值是通过计算得出的，不会产生误判

```
浏览器缓存策略主要包括强缓存和协商缓存。

强缓存是通过设置响应头中的Cache-Control和Expires字段来实现的。Cache-Control是HTTP/1.1中的缓存控制字段，常见的取值有max-age和no-cache等。max-age表示缓存的有效期，单位是秒，no-cache表示强制确认缓存是否过期。Expires是HTTP/1.0中的缓存控制字段，其值是一个绝对时间戳，表示缓存的过期时间。如果客户端的请求命中了强缓存，浏览器会直接从缓存中读取资源，不会向服务器发送请求。

协商缓存是通过设置响应头中的Last-Modified和ETag字段来实现的。Last-Modified表示资源的最后修改时间，ETag是一个字符串，表示资源的标识符。当客户端发起请求时，会在请求头中携带If-Modified-Since和If-None-Match字段，分别表示上一次请求返回的Last-Modified和ETag的值。如果服务端判断资源未被修改，则会返回304 Not Modified状态码，客户端会从缓存中读取资源。

需要注意的是，Last-Modified字段存在时间精度问题，精度只能到秒级别，因此在一秒钟内多次修改资源可能会导致缓存失效的误判。而ETag则是通过计算生成的字符串，相对于Last-Modified更加智能。
```



#### 你知道的前端性能优化手段有哪些？

webpack gzip优化，分包splitPlugin，多进程还是多线程打包happypack

图片 懒加载 CDN

浏览器缓存 强缓存 协商缓存

本地存储 保留数据 cookie localStorage sessionStorage

CDN

服务端渲染 SSR 有效降低首屏渲染时间

DOM操作回流重回

防抖节流

前端模块化机制有哪些？

ES Module  Common JS Module，前者通过export导出import导入，后者通过module.exports导出，required导入



#### http2.0做了哪些改进？

二进制协议、多路复用、头部压缩、数据流传输、服务端推送

```
二进制协议：HTTP/2.0使用二进制协议传输数据，取代了HTTP/1.1中的文本协议，因此可以提高传输效率。

多路复用：HTTP/2.0中可以在同一个TCP连接上进行多个请求和响应，不需要像HTTP/1.1一样为每个请求和响应都建立一个TCP连接，因此可以减少建立连接的次数，提高传输效率。

头部压缩：HTTP/2.0使用HPACK算法对请求和响应头部进行压缩，减少了头部的大小，也提高了传输效率。

数据流传输：HTTP/2.0中将请求和响应分割成多个数据流进行传输，可以更加灵活地组合和处理数据，提高传输效率。

服务端推送：HTTP/2.0中支持服务器主动向客户端推送资源，避免了客户端重复请求相同的资源，也提高了传输效率。
```



## 四：70

#### react为什么需要fiber？

react在在16以前的更新组件，是在虚拟DOM上递归的更新，我们称为stack reconcil，这种更新是不可中断的，这意味着它有可能占据很长一段时间的主线程控制权，而浏览器通常是60hz的，大概就是16.7ms进行一次刷新，如果占据主线程时间过长导致页面没有事件进行重新排列和绘制，会造成卡顿现象，印象用户体验。于是出现了react16版本的fiber架构，他提供了一种可中断的更新，并且在每次更新时对浏览器剩余空闲时间进行询问，如果剩余空闲时间充足才会进行更新任务，这样就不会造成阻塞卡顿，react还基于此设计出了time slice时间分片，将任务划分为一个个小段（大概5ms一个），解决了stack reconcil的cpu瓶颈。

```
React 16 引入了 Fiber 架构，主要解决了两个问题：

长时间的更新操作可能会阻塞主线程，导致页面卡顿，影响用户体验。
无法中断的更新操作意味着无法优先响应高优先级的任务，比如用户输入事件等。
Fiber 架构的实现原理是将每个组件的更新操作拆分为多个小任务，每个任务执行时间不超过 16ms（即一帧的时间），然后在每个任务之间让出主线程控制权，以响应其他高优先级的任务，比如用户输入事件等。这种可中断的更新方式可以将更新操作分散到多个帧中执行，从而避免了长时间阻塞主线程的问题。

另外，Fiber 架构还引入了优先级的概念，分为同步任务和异步任务两种优先级。同步任务优先级高于异步任务，这样可以更快地响应用户的输入事件等高优先级任务。同时，Fiber 架构还支持时间分片技术，将一个大任务拆分成多个小任务，这样可以更好的控制单次任务的执行时间，提高页面性能和响应速度。
```



#### redux中间件机制？

```
Redux 中间件机制的实现原理是基于函数的柯里化（currying）和闭包（closure）特性。一个 Redux 中间件就是接受一个 store 的 dispatch 方法作为参数的函数，这个函数返回的另一个函数，这个返回的函数接受一个 next 函数作为参数，返回另一个函数，这个另一个函数接受一个 action 作为参数，并在执行一些自定义逻辑后，通过调用 next(action) 方法把 action 传递给下一个中间件或 reducer。
一个简单的 Redux 中间件示例：
const logger = (store) => (next) => (action) => {
  console.log('dispatching', action)
  const result = next(action)
  console.log('next state', store.getState())
  return result
}
```



#### bind的实现？

```js
function myBind(fn, context, ...args1) {
  return function (...args2) {
    fn.apply(context || this, [...args1, ...args2]);
  };
}
```



#### 说下generator原理？

生成器会根据yield字段分割代码块，每次只执行到下一个yield，原理就是将函数挂起，交出主线程控制权，等待下一次next()重新获得控制权。虽然看起来像是函数执行中途被挂起，实际上它只是缓存了函数内部状态，并且下次执行时执行到上次节点，然后开始执行

```
Generator 函数的执行过程与普通函数不同。普通函数的执行是一次性的，而 Generator 的执行可以中途暂停，然后再从暂停的地方继续执行。Generator 函数内部维护了一个状态机，通过调用 next() 方法来控制状态的切换。每当执行到 yield 语句时，Generator 函数就会将当前的执行状态保存下来，并返回 yield 后面的值给调用方。当再次调用 next() 方法时，Generator 函数会从上一次暂停的位置继续执行，直到执行到下一个 yield 语句或者函数结束。

当 Generator 函数被调用时，它不会立即执行，而是返回一个迭代器对象。迭代器对象具有 next() 方法，每次调用 next() 方法都会执行 Generator 函数，直到遇到下一个 yield 语句或者函数结束。如果 Generator 函数执行结束，迭代器对象的 done 属性会变为 true，value 属性会是函数的返回值。如果 Generator 函数没有结束，done 属性为 false，value 属性则是 yield 语句后面的值。

总之，Generator 函数的核心原理是通过使用状态机和 yield 语句来实现函数的暂停和恢复，从而可以实现异步编程、流控制等功能。
```



#### flex布局有什么好处？

flex是一种流式布局，他的好处很多，提供了非常简单的使用方法和布局方法，简化布局流程；流式布局支持动态的增删元素；统一的API易于管理；功能强大；

```
这里我来逐一说明一下：

简化布局流程：相比传统的布局方式，如 float 和 position 等，flex 布局提供了非常简单的使用方法和布局方式，可以大大减少编写 CSS 的时间和代码量，同时也更易于维护。

支持动态的增删元素：flex 布局是一种流式布局，可以自动适应容器的大小和内容的变化，当元素数量或大小发生变化时，布局也会自动更新，这使得 flex 布局非常适合响应式设计和动态数据展示。

统一的 API 易于管理：flex 布局提供了一套统一的 API，如 flex-direction、justify-content、align-items、flex-wrap 等，这些属性可以轻松地控制元素的布局和排列方式，使得管理布局变得更加简单和直观。

功能强大：flex 布局不仅支持水平和垂直方向的布局，还支持元素的排序、对齐、伸缩和换行等功能，可以满足各种复杂布局的需求。同时，flex 布局也可以与其他布局方式结合使用，如 grid 布局、position 布局等，进一步扩展了它的功能和灵活性。
```



#### 如何定位内存泄露？

利用浏览器performance，判断内存占用情况

#### 渲染合成层是什么？

合成层是独立的一层，它通常由GPU渲染，硬件加持渲染效率很高，在使用类似transform3D的时候就会将元素放到合成层由GPU渲染

```
渲染合成层（Compositing Layer）是指在浏览器的渲染过程中，将某些元素单独放在一个独立的图层中，通过硬件加速的方式来提高性能。

通常情况下，浏览器的渲染过程是由 CPU 完成的，而 CPU 的计算能力是有限的。当页面中的元素过多、复杂度较高时，CPU 可能会出现卡顿，导致页面性能下降。为了解决这个问题，浏览器引入了渲染合成层的概念。

渲染合成层通常由 GPU 来渲染，而 GPU 的计算速度相对于 CPU 来说更快，因此可以提高页面的渲染性能。可以将一些常常需要频繁重绘的元素，如动画、视频、3D 变换、canvas 等元素单独放在一个合成层中，这样就可以减少 CPU 的计算负担，提高页面的渲染速度。

在实际开发中，可以使用 CSS 的 transform、opacity、filter、will-change 等属性来触发元素的合成层，从而提高页面的渲染性能。需要注意的是，过度使用合成层也可能会影响性能，因此需要合理使用。
```



#### babel是什么，怎么做到的？

babel是下一代js编译器，它最初的作用是将高版本js语法翻译为低版本的js语法提供兼容性支持，后来也开始做各种框架转换到原生js的兼容性。它通过构建抽象语法树，讲高版本语法或抽象框架语法转化了原生语法，并且可以自己编写babel插件对其进行功能扩展

```
Babel 是一个 JavaScript 编译器，可以将 ECMAScript 2015+ 代码转换为向后兼容的 JavaScript 代码，从而可以在当前和旧版浏览器或其他环境中运行。Babel 主要的工作就是将代码分析成抽象语法树（AST），然后对 AST 进行操作，最后将新的 AST 转换回代码。Babel 可以通过插件机制，让用户自定义扩展编译器的功能。

Babel 的编译过程大致如下：

解析：将代码解析成 AST。
转换：对 AST 进行转换操作，如转换箭头函数、类、模块化语法等。
生成：将转换后的 AST 转换成代码。
Babel 的插件机制就是在转换过程中拦截 AST 并修改它，从而实现对特定语法的支持。用户可以根据自己的需要编写插件，通过 Babel 编译器的插件机制来扩展 Babel 的功能。Babel 已经拥有了许多常见的插件，如转换 ES6、ES7、TypeScript、React 等语法，同时也支持自定义插件来满足个性化需求。
```



#### http2.0有哪些不足，http3.0是什么？

http2.0运输层采用TCP协议，头部信息长，需要建立连接，并且TCP存在队头阻塞，虽然保障了传输的可靠性但传输速度较慢。http3.0采用UDP作为传输层协议，UDP是无连接的，提供不可靠传输，头部信息短，而且不存在队头阻塞问题，google以UDP为基础并在上面建立quic协议，保障UDP的可靠传输

```
HTTP/2.0 的主要不足包括：
需要在客户端和服务器之间建立一个持久的连接，这需要进行握手等操作，导致延迟比较大。
头部压缩算法虽然可以压缩头部信息，但是对于一些重复较少的请求，压缩的效果并不好。
HTTP/2.0 的流量控制机制可能存在一些问题，比如服务器可能会通过发送 RST_STREAM 帧来关闭某个流，但客户端可能并没有收到该帧，导致客户端一直等待响应，浪费了带宽。
HTTP/3.0 是基于 QUIC 协议的，采用了 UDP 作为底层传输协议。相比于 TCP，UDP 更加轻量级，不需要建立连接，同时还能够避免 TCP 的队头阻塞问题。QUIC 协议还提供了类似于 TCP 的可靠传输机制，同时也支持多路复用和头部压缩等特性。HTTP/3.0 在保证可靠传输的同时，还具有较高的速度。
```



## 五：



## 六：



## 七：



## 八：



## 九：



## 十：

