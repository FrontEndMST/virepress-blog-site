# 模拟题

## 一：75

#### react setState是同步还是异步?

setState是同步代码，但是在React中他的表现像是异步的，原因在于setState在调用后不会立刻更新状态

```
虽然 setState 是同步代码，但在 React 中，它的表现却像是异步的。这是因为在调用 setState 后，React 并不会立即更新状态，而是将该更新推迟到某个合适的时机再执行，这个过程称为“批处理”。

具体来说，当我们调用 setState 时，React 会将该更新加入到一个更新队列中。然后，React 会检查是否有其他更新操作需要执行，如果有，那么它会将所有的更新操作合并成一个更新，然后一次性执行。这个过程可以提高性能，避免了频繁的渲染操作。

当所有的更新操作都完成后，React 会重新渲染组件，并更新组件的状态。在这个过程中，React 会根据更新队列中的操作进行高效的 DOM 操作，以最小化页面的重绘和回流。

需要注意的是，当我们在 setState 中使用回调函数时，回调函数中的代码会在状态更新完成后执行。这是因为 React 会在更新组件状态后，立即执行回调函数，以确保回调函数中使用的状态是最新的。

需要强调的是，虽然 setState 的执行过程看起来像是异步的，但它并不是真正的异步操作，也不会涉及异步回调、Promise 或者异步函数等异步编程方式。因此，在使用 setState 时，我们不需要考虑异步代码的复杂性和不确定性，可以像编写同步代码一样编写 setState 的回调函数。
```



#### 什么是高阶组件，请举例说明?

HOC，他接收一个组件，返回一个新组件，通常有以下几种用法：1.增强props 2.反向继承。增强props很好理解在HOC中为每一个传入的组件附上额外的props，抽离代码逻辑减小耦合。反向继承比较复杂，他通过继承传入组件的方式可以访问到组件中的生命周期和state，并且可以调用父类组件的render函数，通常可以用来控制渲染等。React自身具备的HOC有如React.memo，React Router 中的withRouter也是HOC

```
高阶组件（Higher Order Component，HOC）是一个函数，接收一个组件作为参数，并返回一个新的组件。这个新的组件可以增强或者改变传入的组件的行为。
增强组件的功能：通过给组件传入额外的 props，或者重写组件的某些方法，从而增强组件的功能。
处理逻辑复用：通过将多个组件共享的逻辑封装在一个 HOC 中，从而减少重复代码的出现。
```



#### 解释一下原型链?

原型链是一种查找机制，当我们访问一个对象中的某个属性时会现在对象内部查找属性，如果没有则会访问prototype，如此反复，这种链式的查找方式就是原型链查找

```
在 JavaScript 中，每个对象都有一个内部属性 [[Prototype]]，它指向它的原型对象（或者说是它的构造函数的 prototype 属性）。如果我们访问一个对象中的某个属性，但该属性在对象本身上不存在，那么 JavaScript 引擎会沿着对象的原型链向上查找，直到找到该属性或者到达原型链的末尾（即 null）为止。
```



#### instanceof原理?

类在继承时会绑定原型到父类的原型上，所以instanceof的原理就是遍历对象的prototype，如果与类的原型匹配则返回true

```
instanceof 的原理是，它会检查对象的原型链上是否存在类的原型。具体来说，它会沿着对象的 [[Prototype]] 链向上查找，直到找到原型为 null 或者找到与类的原型相同的原型为止。如果找到了与类的原型相同的原型，那么就认为该对象是该类的实例，返回 true；否则返回 false。
```



#### apply和call的作用及区别?

apply和call的作用都是调用函数并修改函数的this为传入的this值，是劫持函数的方法，区别在于apply接收一个参数数组，而call接收多个参数



#### position有哪些值，作用分别是什么?

relative: 相对定位，可以改变在文档流中的位置，以自身左上角为基准点

absolute：绝对定位，脱离文档流，可以改变自身的位置，以最近的定位为非static的父元素

static：默认值，不受left这些属性影响

stricky：在可视范围内时与relative相同，不在时与fixed相同

fixed：固定定位，根据浏览器窗口定位

```
CSS 中的 position 属性用于设置元素的定位方式。它有以下四个可能的值：

static：默认值，元素在文档流中的位置不受 top、right、bottom 和 left 属性的影响，也不能使用 z-index 属性来改变元素的层叠顺序。
relative：元素在文档流中原有的位置不变，但可以通过设置 top、right、bottom 和 left 属性来相对移动元素的位置。如果设置了 z-index 属性，则可以改变元素的层叠顺序。
absolute：元素从文档流中脱离，相对于最近的已定位祖先元素（祖先元素中有一个具有非 static 的 position 值），根据设置的 top、right、bottom 和 left 属性进行绝对定位。如果没有已定位的祖先元素，则相对于文档的初始包含块进行定位。同样可以使用 z-index 属性改变元素的层叠顺序。
fixed：元素相对于浏览器窗口进行定位，即使页面滚动，元素的位置也不会改变。同样可以使用 top、right、bottom 和 left 属性进行定位，也可以使用 z-index 属性改变元素的层叠顺序。
另外，你提到了 sticky 定位，但是这个值并不是 position 属性的取值之一，而是一种相对于滚动容器（例如浏览器窗口或某个元素）进行定位的特殊定位方式。sticky 定位需要设置 top、right、bottom 或 left 属性中的至少一个，表示元素在容器内滚动到某个阈值时开始固定在容器的相应位置，超过另一个阈值时又开始跟随容器滚动。
```



#### 说下你对DOM树的理解?

每一个元素之间存在父子关系和兄弟关系，他们共同构成了一颗DOM树，其中document对象为树的根节点

```
在 HTML 中，所有元素（包括文本节点和注释节点）都可以看作是一棵树上的节点，这棵树就是 DOM 树（Document Object Model Tree）。

DOM 树的根节点是 document 对象，它代表整个 HTML 文档。document 对象下有一个子节点 html，它代表 <html> 元素。html 元素下有两个子节点：head 和 body，分别代表 <head> 和 <body> 元素。依次类推，每个元素下面都可以有任意多个子节点，这些子节点也可以有自己的子节点，从而形成了一棵树形结构。

DOM 树的节点之间有父子关系和兄弟关系。一个节点的父节点是它的直接上级，它的子节点是它的直接下级，而和它同级的节点是它的兄弟节点。在 DOM 树中，任意两个节点之间都存在一条唯一的路径，这条路径由它们之间的父子关系连接而成。

DOM 树的结构对于 JavaScript 操作页面元素非常重要，因为它提供了一种便捷的方式来访问和操作页面中的元素。JavaScript 可以通过访问 DOM 树中的节点来获取页面元素的属性和内容，还可以动态地修改 DOM 树中的节点来改变页面的外观和行为。
```



#### 重排和重绘是什么，有什么区别?

重排也叫回流，通常是对元素的宽高等属性进行了更改，影响了在文档流中的位置，需要浏览器根据新的属性将文档重排，重绘通常是改变了元素的一些样式，需要重新加载元素样式。回流一定触发重绘，但重绘不一定触发回流

```
重排（reflow）和重绘（repaint）是浏览器渲染页面时的两个过程。

重排（也称为回流）是指当浏览器需要重新计算文档的布局信息时，比如修改了元素的尺寸、位置、内容或结构等，就会触发重排。重排会使得浏览器重新计算元素的大小和位置等信息，并重新构建页面的布局树和绘制树，这个过程非常耗费性能。

重绘是指当元素的样式发生变化时，浏览器需要重新绘制元素的外观，但不需要重新计算元素的布局信息。重绘不会影响布局树，而只会更新绘制树中的节点，因此比重排的代价要小得多。

需要注意的是，重排一定会触发重绘，因为元素的几何属性发生变化后必须重新绘制。但重绘不一定会触发重排，因为元素的样式属性发生变化后可能不会影响布局信息。

因此，为了提高页面的性能，我们应该尽量减少重排和重绘的次数。比如可以通过修改样式时尽量使用类名替代直接操作样式、使用文档片段避免频繁修改 DOM 结构等方法来减少重排和重绘的次数。
```



#### https加密过程是怎样的?

http是一个超文本传输协议，而https是加密超文本传输协议，他在应用层和传输层之间新增了一层SSL/TSL用于加密。https中SSL三次握手，以构建安全的https连接，具体是：客户端发送ssl连接请求，内容包括客户端能够接受的CA证书版本和hash算法并发送一个随机数，服务端接收到后返回选择的CA证书和hash算法，并返回一个随机数，客户端验证CA证书有效性后，用客户端公钥加密一个会话密钥发送到服务端，服务端用自己的私钥解密后建立https连接。这个过程中最需要确保的就是服务端发送CA证书和公钥，服务端会采用数字签名的方法保证数据的完整性和安全性

```
HTTPS（Hyper Text Transfer Protocol Secure）是一种通过 SSL/TLS 加密传输数据的 HTTP 协议。它在应用层和传输层之间新增了一层 SSL/TLS 协议，用于加密和验证数据的完整性和安全性。

HTTPS 的加密过程主要包括 SSL 握手和加密通信两个阶段。

在 SSL 握手阶段，客户端和服务端进行三次握手，以建立安全的 HTTPS 连接。具体过程如下：

客户端发送 SSL 连接请求，包括 SSL 版本号、加密算法列表和一个随机数，以及可能需要验证的客户端证书（可选）。
服务端接收到 SSL 连接请求后，回应一个 SSL 连接响应，包括 SSL 版本号、选择的加密算法和一个随机数，以及可能需要验证的服务端证书（可选）。
客户端收到服务端的 SSL 连接响应后，根据服务端的证书验证其有效性，并生成一个用于后续对称加密的会话密钥。客户端用服务端的公钥加密会话密钥，并发送给服务端。
服务端接收到客户端发送的加密的会话密钥后，用自己的私钥解密，获取会话密钥，并生成用于后续对称加密的密钥。服务端用客户端的公钥加密密钥，并发送给客户端。
在加密通信阶段，客户端和服务端使用会话密钥进行对称加密和解密，保证数据的机密性和完整性。

在 HTTPS 连接中，最需要确保的是服务端发送的 CA 证书和公钥的安全性和完整性，服务端会采用数字签名的方法保证数据的可靠性。同时，HTTPS 还可以防止中间人攻击和窃听等安全问题，提供更加安全的网络通信方式。
```



数字签名的过程是什么样？为什么他能保证安全可靠？

```
数字签名是一种对数据进行认证和保护的方法，用于验证数据的完整性和真实性，防止数据被篡改或伪造。数字签名的过程主要包括签名和验证两个步骤。

在签名过程中，发送方使用私钥对数据进行加密，生成数字签名，并将数字签名和原始数据一起传输给接收方。接收方收到数据后，使用发送方的公钥对数字签名进行解密，得到原始数据并验证其完整性和真实性。

数字签名的细节包括：

数字签名使用的是公钥加密和私钥解密的方式，因此发送方需要持有自己的私钥，而接收方需要持有发送方的公钥。
数字签名算法通常包括哈希函数和加密函数两部分。哈希函数用于将原始数据转换为固定长度的摘要，而加密函数用于对摘要进行加密生成数字签名。
数字签名的生成过程需要保证私钥的安全性，防止私钥被泄漏或被攻击者获取，从而导致数字签名失去保护作用。
数字签名的验证过程需要保证公钥的安全性，防止公钥被篡改或被攻击者替换，从而导致验证结果被篡改或伪造。
数字签名算法的选择需要根据安全性和效率的考虑，常见的数字签名算法包括 RSA、DSA 和 ECDSA 等。
总之，数字签名是一种重要的数据保护技术，可以有效地验证数据的完整性和真实性，防止数据被篡改或伪造，保护数据的安全性。
```



#### 为什么数字签名+CA证书能够防止中间人攻击?

```
数字签名和 CA 证书结合使用可以防止中间人攻击，因为数字签名和 CA 证书提供了一种安全的身份验证机制，确保通信双方的身份和数据的完整性，防止中间人篡改或伪造数据。

在数字签名和 CA 证书的过程中，发送方使用私钥对数据进行加密生成数字签名，并使用 CA 证书对数字签名进行认证，确保数字签名的真实性和完整性。接收方使用 CA 证书验证数字签名，并使用发送方的公钥对数字签名进行解密，以确保数据的完整性和真实性。

同时，CA 证书的验证过程也能够防止中间人攻击。在 HTTPS 连接中，服务端会向客户端发送自己的 CA 证书，客户端通过根据自己的信任列表验证 CA 证书的真实性，确保服务端的身份和数据的完整性。如果中间人试图伪造服务端的身份或篡改数据，客户端就会因为无法验证 CA 证书而拒绝连接，从而防止中间人攻击。

因此，数字签名和 CA 证书结合使用可以提供一种安全的身份验证机制，确保通信双方的身份和数据的完整性，防止中间人攻击，保护网络通信的安全性。
```



## 二：60

#### react为什么需要合成事件？

react如果不使用合成事件，那就只能调用原生的事件，所以接下来我将阐述的是react合成事件相较于原生事件的优点：1.react合成事件可以自定义event对象 2.合成事件底层采用事件池设计，事件对象可以重复使用，减小了开销 3.react合成事件拥有更好的跨平台兼容性，并且更好统一管理

```
React 合成事件的优点包括：

自定义 event 对象：React 合成事件将所有浏览器的事件都统一封装成了一个合成事件对象，这个对象可以在不同浏览器和平台下保持一致，同时还可以添加自定义属性和方法。

事件池设计：React 合成事件底层采用了事件池的设计，即在事件触发后，合成事件对象会被重置并放回到事件池中，下次再触发同类型事件时可以直接复用，避免了频繁创建和销毁大量的事件对象，减小了内存开销。

跨平台兼容性：React 合成事件可以在不同平台和浏览器中保持一致，以及更好地管理事件的处理和传递，避免了平台差异性带来的问题，提高了开发效率。
```



#### 为什么有时react两次setState，只执行一次

react的setState方法是同步调用，但是由于其特殊的执行时期，导致他呈现异步的效果，这个时期就是react的批处理，react对于多个setState调用，会放入一个队列中，并且根据isBatchingUpdates字段来判断是否要进行setState合并操作，也就是批处理过程，如果为true，则将多个setState进行合并，所以只调用一次

```
React 的 setState 方法是同步调用的，但是它的更新并不是立即执行的，而是被批量处理的，这个批量处理的过程会将多次 setState 调用合并成一次，以提高渲染性能和优化用户体验。

React 内部使用了一个叫做“事务”的机制来实现这个批量处理的过程，它会在一些特定的场景中自动启用，如在 React 生命周期函数、React 事件处理函数、React 异步更新等情况下。

当我们在 React 生命周期函数中调用 setState 方法时，React 会自动将这些调用合并成一次更新操作，在下一个更新周期统一进行处理。这个更新周期有一个名字叫做“批量更新模式”，它的具体实现是通过一个叫做“事务队列”的机制来实现的。

在批量更新模式中，React 会将多个 setState 调用放到一个队列里，等到下一个更新周期再进行处理。如果在同一个更新周期内多次调用 setState，React 会合并这些调用，只进行一次更新操作，从而提高性能。

因此，有时候我们在调用 setState 方法时，可能会看到只有一次更新操作被执行，即使我们多次调用了 setState。这是因为 React 内部自动启用了批量更新模式，将多次更新操作合并成了一次，从而提高了性能。
```



#### redux有哪些原则？

```
Redux 的三个核心原则分别是：单一数据源、状态只读、使用纯函数来执行修改。

单一数据源：Redux 应用中的状态数据应该只存储在唯一的 store 中，而不是分散在多个组件或者对象中。这样可以确保状态的一致性和可预测性。

状态只读：Redux 中的状态是只读的，不能直接修改，只能通过 dispatch 来触发对应的 action，由 reducer 来修改状态。这样可以避免状态被误修改，同时也方便跟踪状态的变化。

使用纯函数来执行修改：Redux 中的 reducer 必须是一个纯函数，接收旧的状态和 action，返回新的状态。这样可以确保修改状态的过程是可预测和可追溯的。
```



#### es5实现继承

es5的继承方式有多种：原型链继承，借用构造函数继承，原型式继承，寄生式继承，组合式继承，寄生组合式继承等。可能有缺漏的，实现我就不细讲了



#### CSS选择器有哪些？

```
元素选择器：通过元素名来选择元素，如 div、p、ul 等。

ID 选择器：通过元素的 ID 属性来选择元素，如 #myId。

类选择器：通过元素的 class 属性来选择元素，如 .myClass。

属性选择器：通过元素的属性来选择元素，如 [title]、[href="https://www.example.com"] 等。

通配符选择器：选择所有元素，如 *。

组合选择器：将多个选择器组合在一起，如 .myClass p、div.myClass 等。

后代选择器：选择某个元素的后代元素，如 div p、ul li 等。

子选择器：选择某个元素的直接子元素，如 ul > li。

相邻兄弟选择器：选择紧接在某个元素后面的相邻元素，如 h1 + p。

兄弟选择器：选择某个元素后面的所有兄弟元素，如 h1 ~ p。

伪类选择器：选择元素的特定状态，如 :hover、:active、:visited 等。

伪元素选择器：选择元素的某个虚拟部分，如 ::before、::after、::first-line 等。
```



说下事件模型

DOM事件触发主要分为三个阶段：捕获阶段 处于目标阶段 冒泡阶段。通常添加事件监听器时可以传入第三个参数，默认为false冒泡阶段，true则为捕获阶段。并且可以在某一层冒泡上通过event.stopPropergation停止冒泡过程

```
说下事件模型

DOM事件触发主要分为三个阶段：捕获阶段 处于目标阶段 冒泡阶段。通常添加事件监听器时可以传入第三个参数，默认为false冒泡阶段，true则为捕获阶段。并且可以在某一层冒泡上通过event.stopPropergation停止冒泡过程
```

如何减少白屏的时间

SSR服务端渲染，降低js文件大小，合理的webpack分包策略等

```
服务器端渲染（SSR）：使用服务器端渲染可以在服务器端生成 HTML 内容，从而减少客户端加载和渲染的时间，从而减少白屏时间。

按需加载：对于一些不必要的资源，例如图片、CSS 和 JavaScript 文件等，可以采用按需加载的方式，只有当需要使用时才加载，可以使用懒加载、预加载等技术。

合理的代码分割：将代码分割成多个小的模块，然后按需加载，可以减少首屏加载时需要下载的 JavaScript 文件大小，从而减少白屏时间。

压缩和缓存：使用 Gzip 等压缩技术可以减少文件大小，从而提高加载速度，同时使用浏览器缓存可以减少重复下载的次数。

使用 CDN：使用 CDN 可以将资源分布到多个服务器上，从而提高资源的访问速度和下载速度。

减少 HTTP 请求：减少页面中的 HTTP 请求可以减少加载时间，可以通过合并 JavaScript 和 CSS 文件、使用精灵图等方式来实现。

预加载：对于一些重要但不会立即使用的资源，例如图片等，可以使用预加载的方式，在页面加载完成后预先加载这些资源，从而提高后续使用时的速度。
```

#### TCP3次握手过程

客户端发送建立连接报文，并发送SYN，进入SYN-SEND状态，服务端接收到SYN后进入listen状态，然后发送确认连接报文，进入SYN-RECV状态，客户端接收到服务端确认连接报文后建立连接，进入establish状态，向服务端发送确认报文，服务端接收到连报文也进入establish状态

```
客户端发送SYN报文：客户端向服务器端发送一个SYN报文，其中SYN标志位被设置为1，表示客户端请求建立连接。同时，客户端会随机生成一个初始序列号（ISN）作为第一个数据包的序列号。

服务端发送SYN+ACK报文：服务器端收到客户端的SYN报文后，如果同意建立连接，则向客户端发送一个SYN+ACK报文。其中SYN标志位被设置为1，表示服务器端同意建立连接；ACK标志位被设置为1，表示服务器端已经收到客户端的SYN报文；同时，服务器端也会随机生成一个初始序列号作为第一个数据包的序列号。

客户端发送ACK报文：客户端收到服务器端的SYN+ACK报文后，向服务器端发送一个ACK报文，其中ACK标志位被设置为1，表示客户端已经收到服务器端的SYN+ACK报文，并确认建立连接。同时，客户端也会把服务器端的初始序列号加1作为第一个数据包的序列号。
```



## 三：70

#### react合成事件是什么，和原生事件的区别？

react合成事件是react内部实现的事件处理系统，相比于原生事件系统做了诸多优化。比如更好的性能，合成事件采用了事件池设计，event对象不会被销毁，可以重复使用，减小了开销。其次在合成事件中可以自定义event对象的属性，方便我们更好的扩展

```
首先，React合成事件是基于浏览器原生事件机制实现的，但是React会在事件冒泡阶段对原生事件进行包装，形成一个合成事件对象，来统一处理不同浏览器之间的差异。

其次，React合成事件与原生事件的主要区别在于性能和处理方式上。React合成事件采用了事件池技术，可以重用事件对象，减少内存开销，提高性能。此外，React合成事件对事件处理方式进行了优化，例如对于一些事件处理函数会进行批量更新，避免频繁的重新渲染。

最后，React合成事件还提供了一些其他的扩展功能，例如可拖拽、可复制、可粘贴等。在React开发中，一般推荐使用React合成事件来处理用户交互事件，因为它比原生事件更高效、更易用、更可靠。
```



#### react如何处理异常？

react的异常处理通常在类式组件中，可以通过componentDidCatch和should...的两个API对错误进行捕获，他们仅能捕获react所产生的错误，像ErrorBoundery这样捕获下层组件产生错误，ErrorBoundery的设计通过捕获底层组件抛出的Promise实现错误捕获，如果要捕获代码中的错误还是应该使用trycatch

```
在React中，可以通过错误边界（Error Boundaries）机制来捕获和处理组件渲染过程中的异常。错误边界是一种React组件，它可以在其子组件中捕获并处理错误，防止错误的传播影响整个应用的正常运行。

在类组件中，可以使用componentDidCatch()方法来捕获子组件中的错误。当子组件发生错误时，componentDidCatch()方法会被调用，可以在该方法中进行错误的处理、记录或反馈等操作。需要注意的是，componentDidCatch()只能捕获子组件中的错误，而无法捕获在事件处理函数、异步操作和服务端渲染等场景中产生的错误。

另外，React还提供了shouldComponentUpdate()方法来控制组件是否重新渲染。可以在该方法中对组件的状态和属性进行比较，来决定是否需要重新渲染组件。这样可以有效减少组件的渲染次数，提高应用的性能。

需要注意的是，React的错误边界机制并不能完全避免应用的崩溃或异常，因此在开发过程中，还需要注意编写健壮性高的代码，以避免出现意外的错误。
```



#### 闭包的作用和原理？

闭包的定义为：在函数中能够访问到另一个函数作用域中的变量。闭包在我看来是一种变量的保护机制，由于作用域的关系函数内部的变量无法被外部访问，并且如果函数内部的变量被外部引用那么他在函数结束时不会被垃圾回收，通过这种方法我们可以实现一个不被外界操控的被保护的私有变量，它的原理就是通过划分新的作用域来保护变量不被外界访问

```
闭包是指在一个函数内部定义的函数可以访问该函数作用域内的变量，而这些变量在函数外部是无法访问的。由于闭包可以访问外部函数的变量，因此可以用来创建私有变量和私有方法，实现模块化编程。

闭包的原理是：当函数执行完毕后，其执行上下文会被销毁，其中的变量也会被释放。但是，如果存在闭包，外部函数的执行上下文会被保存在内存中，因为内部函数引用了外部函数的变量，这些变量也会被保存在内存中。这样，即使外部函数执行完毕，内部函数依然可以访问外部函数的变量，因为它们在内存中并没有被释放。

闭包在JavaScript中的应用非常广泛，比如封装私有变量和方法、实现柯里化、异步编程等。需要注意的是，由于闭包会占用内存，如果不恰当地使用闭包，可能会导致内存泄漏等问题，因此在使用闭包时需要注意内存管理。
```



#### 0.1+0.2为什么不等于0.3？

首先IEEE 754对浮点数的计算方式为：小数部分乘2取整，但是小数存储位数存在限制，所以可能存在精度损失，在js中如果要解决这个问题，可以通过Math.abs(0.1+0.2-0.3)<Math.EPSILON来判断

```
0.1+0.2为什么不等于0.3

首先IEEE对浮点数的计算方式为：小数部分乘2取整，但是小数存储位数存在限制，所以可能存在精度损失，在js中如果要解决这个问题，可以通过Math.abs(0.1+0.2-0.3)<Math.EPSILON来判断
```



#### 什么是BFC，BFC有什么作用，如何形成BFC?

BFC是一个独立渲染区域，它定义了BFC区域内标签之前的一些规则，比如兄弟节点都是块级元素，他们之间的margin会进行重叠，子节点margin会影响父节点，浮动元素环绕这些。BFC可以人为的划分，我们可以为其添加特定的属性来划分BFC

```
你的回答基本正确。BFC全称为块级格式化上下文（Block Formatting Context），它是Web页面中的一种CSS渲染模式，是一个独立的渲染区域，具有一定的布局规则和渲染机制。BFC中的元素按照一定的规则进行布局，不会影响到BFC区域外的元素。

BFC的作用主要有三个：

清除浮动：当一个元素设置为BFC后，它的子元素浮动时，不会影响到BFC区域外的元素，同时BFC区域会自动扩展以适应浮动元素的高度，从而避免了父元素高度塌陷的问题。

防止margin重叠：当BFC中相邻的元素的margin发生重叠时，BFC会把它们分开，从而避免了margin重叠的问题。

创建独立的渲染区域：BFC区域内的元素不会影响到外部元素的布局，同时BFC区域也不会受到外部元素的影响，从而可以创建独立的渲染区域。

BFC的形成有多种方式，最常见的方式是通过设置元素的display、position、float、overflow等属性来触发BFC机制。例如，当一个元素设置为float除none以外的值、position除static以外的值、display除inline以外的值、overflow除visible以外的值时，就会形成BFC。此外，还可以通过设置父元素的属性来触发BFC机制，比如父元素设置overflow为hidden或auto时，就可以触发子元素形成BFC。
```



#### 浏览器缓存策略是怎样的？

浏览器的缓存分为强缓存和协商缓存，强缓存优先级高于协商缓存。在第一次请求后，如果响应头中存在cache-control和expires字段，一个返回max-age+秒数，一个返回绝对时间戳，在下一次请求时会根据这两个字段判断请求缓存是否过期，如果还在有效期内则直接从浏览器中读取缓存。如果强缓存未命中，则会进行协商缓存判断，协商缓存顾名思义是要与服务端进行"协商"来判断是否要读取缓存的，第一次请求的响应头中会存在last-modified和Etag字段来记录资源的最后修改时间，而在请求时会加入if-modified-since字段进行协商缓存判断，如果判断资源未被修改，则依然从浏览器缓存中读取请求信息。值得一提的是，last-modifed字段存在时间精度问题，他的精度为秒，如果在一秒钟更改多次，可能会产生误判，Etag相对而言更加智能，他的值是通过计算得出的，不会产生误判

```
浏览器缓存策略主要包括强缓存和协商缓存。

强缓存是通过设置响应头中的Cache-Control和Expires字段来实现的。Cache-Control是HTTP/1.1中的缓存控制字段，常见的取值有max-age和no-cache等。max-age表示缓存的有效期，单位是秒，no-cache表示强制确认缓存是否过期。Expires是HTTP/1.0中的缓存控制字段，其值是一个绝对时间戳，表示缓存的过期时间。如果客户端的请求命中了强缓存，浏览器会直接从缓存中读取资源，不会向服务器发送请求。

协商缓存是通过设置响应头中的Last-Modified和ETag字段来实现的。Last-Modified表示资源的最后修改时间，ETag是一个字符串，表示资源的标识符。当客户端发起请求时，会在请求头中携带If-Modified-Since和If-None-Match字段，分别表示上一次请求返回的Last-Modified和ETag的值。如果服务端判断资源未被修改，则会返回304 Not Modified状态码，客户端会从缓存中读取资源。

需要注意的是，Last-Modified字段存在时间精度问题，精度只能到秒级别，因此在一秒钟内多次修改资源可能会导致缓存失效的误判。而ETag则是通过计算生成的字符串，相对于Last-Modified更加智能。
```



#### 你知道的前端性能优化手段有哪些？

webpack gzip优化，分包splitPlugin，多进程还是多线程打包happypack

图片 懒加载 CDN

浏览器缓存 强缓存 协商缓存

本地存储 保留数据 cookie localStorage sessionStorage

CDN

服务端渲染 SSR 有效降低首屏渲染时间

DOM操作回流重回

防抖节流

前端模块化机制有哪些？

ES Module  Common JS Module，前者通过export导出import导入，后者通过module.exports导出，required导入



#### http2.0做了哪些改进？

二进制协议、多路复用、头部压缩、数据流传输、服务端推送

```
二进制协议：HTTP/2.0使用二进制协议传输数据，取代了HTTP/1.1中的文本协议，因此可以提高传输效率。

多路复用：HTTP/2.0中可以在同一个TCP连接上进行多个请求和响应，不需要像HTTP/1.1一样为每个请求和响应都建立一个TCP连接，因此可以减少建立连接的次数，提高传输效率。

头部压缩：HTTP/2.0使用HPACK算法对请求和响应头部进行压缩，减少了头部的大小，也提高了传输效率。

数据流传输：HTTP/2.0中将请求和响应分割成多个数据流进行传输，可以更加灵活地组合和处理数据，提高传输效率。

服务端推送：HTTP/2.0中支持服务器主动向客户端推送资源，避免了客户端重复请求相同的资源，也提高了传输效率。
```



## 四：70

#### react为什么需要fiber？

react在在16以前的更新组件，是在虚拟DOM上递归的更新，我们称为stack reconcil，这种更新是不可中断的，这意味着它有可能占据很长一段时间的主线程控制权，而浏览器通常是60hz的，大概就是16.7ms进行一次刷新，如果占据主线程时间过长导致页面没有事件进行重新排列和绘制，会造成卡顿现象，印象用户体验。于是出现了react16版本的fiber架构，他提供了一种可中断的更新，并且在每次更新时对浏览器剩余空闲时间进行询问，如果剩余空闲时间充足才会进行更新任务，这样就不会造成阻塞卡顿，react还基于此设计出了time slice时间分片，将任务划分为一个个小段（大概5ms一个），解决了stack reconcil的cpu瓶颈。

```
React 16 引入了 Fiber 架构，主要解决了两个问题：

长时间的更新操作可能会阻塞主线程，导致页面卡顿，影响用户体验。
无法中断的更新操作意味着无法优先响应高优先级的任务，比如用户输入事件等。
Fiber 架构的实现原理是将每个组件的更新操作拆分为多个小任务，每个任务执行时间不超过 16ms（即一帧的时间），然后在每个任务之间让出主线程控制权，以响应其他高优先级的任务，比如用户输入事件等。这种可中断的更新方式可以将更新操作分散到多个帧中执行，从而避免了长时间阻塞主线程的问题。

另外，Fiber 架构还引入了优先级的概念，分为同步任务和异步任务两种优先级。同步任务优先级高于异步任务，这样可以更快地响应用户的输入事件等高优先级任务。同时，Fiber 架构还支持时间分片技术，将一个大任务拆分成多个小任务，这样可以更好的控制单次任务的执行时间，提高页面性能和响应速度。
```



#### redux中间件机制？

```
Redux 中间件机制的实现原理是基于函数的柯里化（currying）和闭包（closure）特性。一个 Redux 中间件就是接受一个 store 的 dispatch 方法作为参数的函数，这个函数返回的另一个函数，这个返回的函数接受一个 next 函数作为参数，返回另一个函数，这个另一个函数接受一个 action 作为参数，并在执行一些自定义逻辑后，通过调用 next(action) 方法把 action 传递给下一个中间件或 reducer。
一个简单的 Redux 中间件示例：
const logger = (store) => (next) => (action) => {
  console.log('dispatching', action)
  const result = next(action)
  console.log('next state', store.getState())
  return result
}
```



#### bind的实现？

```js
function myBind(fn, context, ...args1) {
  return function (...args2) {
    fn.apply(context || this, [...args1, ...args2]);
  };
}
```



#### 说下generator原理？

生成器会根据yield字段分割代码块，每次只执行到下一个yield，原理就是将函数挂起，交出主线程控制权，等待下一次next()重新获得控制权。虽然看起来像是函数执行中途被挂起，实际上它只是缓存了函数内部状态，并且下次执行时执行到上次节点，然后开始执行

```
Generator 函数的执行过程与普通函数不同。普通函数的执行是一次性的，而 Generator 的执行可以中途暂停，然后再从暂停的地方继续执行。Generator 函数内部维护了一个状态机，通过调用 next() 方法来控制状态的切换。每当执行到 yield 语句时，Generator 函数就会将当前的执行状态保存下来，并返回 yield 后面的值给调用方。当再次调用 next() 方法时，Generator 函数会从上一次暂停的位置继续执行，直到执行到下一个 yield 语句或者函数结束。

当 Generator 函数被调用时，它不会立即执行，而是返回一个迭代器对象。迭代器对象具有 next() 方法，每次调用 next() 方法都会执行 Generator 函数，直到遇到下一个 yield 语句或者函数结束。如果 Generator 函数执行结束，迭代器对象的 done 属性会变为 true，value 属性会是函数的返回值。如果 Generator 函数没有结束，done 属性为 false，value 属性则是 yield 语句后面的值。

总之，Generator 函数的核心原理是通过使用状态机和 yield 语句来实现函数的暂停和恢复，从而可以实现异步编程、流控制等功能。
```



#### flex布局有什么好处？

flex是一种流式布局，他的好处很多，提供了非常简单的使用方法和布局方法，简化布局流程；流式布局支持动态的增删元素；统一的API易于管理；功能强大；

```
这里我来逐一说明一下：

简化布局流程：相比传统的布局方式，如 float 和 position 等，flex 布局提供了非常简单的使用方法和布局方式，可以大大减少编写 CSS 的时间和代码量，同时也更易于维护。

支持动态的增删元素：flex 布局是一种流式布局，可以自动适应容器的大小和内容的变化，当元素数量或大小发生变化时，布局也会自动更新，这使得 flex 布局非常适合响应式设计和动态数据展示。

统一的 API 易于管理：flex 布局提供了一套统一的 API，如 flex-direction、justify-content、align-items、flex-wrap 等，这些属性可以轻松地控制元素的布局和排列方式，使得管理布局变得更加简单和直观。

功能强大：flex 布局不仅支持水平和垂直方向的布局，还支持元素的排序、对齐、伸缩和换行等功能，可以满足各种复杂布局的需求。同时，flex 布局也可以与其他布局方式结合使用，如 grid 布局、position 布局等，进一步扩展了它的功能和灵活性。
```



#### 如何定位内存泄露？

利用浏览器performance，判断内存占用情况

#### 渲染合成层是什么？

合成层是独立的一层，它通常由GPU渲染，硬件加持渲染效率很高，在使用类似transform3D的时候就会将元素放到合成层由GPU渲染

```
渲染合成层（Compositing Layer）是指在浏览器的渲染过程中，将某些元素单独放在一个独立的图层中，通过硬件加速的方式来提高性能。

通常情况下，浏览器的渲染过程是由 CPU 完成的，而 CPU 的计算能力是有限的。当页面中的元素过多、复杂度较高时，CPU 可能会出现卡顿，导致页面性能下降。为了解决这个问题，浏览器引入了渲染合成层的概念。

渲染合成层通常由 GPU 来渲染，而 GPU 的计算速度相对于 CPU 来说更快，因此可以提高页面的渲染性能。可以将一些常常需要频繁重绘的元素，如动画、视频、3D 变换、canvas 等元素单独放在一个合成层中，这样就可以减少 CPU 的计算负担，提高页面的渲染速度。

在实际开发中，可以使用 CSS 的 transform、opacity、filter、will-change 等属性来触发元素的合成层，从而提高页面的渲染性能。需要注意的是，过度使用合成层也可能会影响性能，因此需要合理使用。
```



#### babel是什么，怎么做到的？

babel是下一代js编译器，它最初的作用是将高版本js语法翻译为低版本的js语法提供兼容性支持，后来也开始做各种框架转换到原生js的兼容性。它通过构建抽象语法树，讲高版本语法或抽象框架语法转化了原生语法，并且可以自己编写babel插件对其进行功能扩展

```
Babel 是一个 JavaScript 编译器，可以将 ECMAScript 2015+ 代码转换为向后兼容的 JavaScript 代码，从而可以在当前和旧版浏览器或其他环境中运行。Babel 主要的工作就是将代码分析成抽象语法树（AST），然后对 AST 进行操作，最后将新的 AST 转换回代码。Babel 可以通过插件机制，让用户自定义扩展编译器的功能。

Babel 的编译过程大致如下：

解析：将代码解析成 AST。
转换：对 AST 进行转换操作，如转换箭头函数、类、模块化语法等。
生成：将转换后的 AST 转换成代码。
Babel 的插件机制就是在转换过程中拦截 AST 并修改它，从而实现对特定语法的支持。用户可以根据自己的需要编写插件，通过 Babel 编译器的插件机制来扩展 Babel 的功能。Babel 已经拥有了许多常见的插件，如转换 ES6、ES7、TypeScript、React 等语法，同时也支持自定义插件来满足个性化需求。
```



#### http2.0有哪些不足，http3.0是什么？

http2.0运输层采用TCP协议，头部信息长，需要建立连接，并且TCP存在队头阻塞，虽然保障了传输的可靠性但传输速度较慢。http3.0采用UDP作为传输层协议，UDP是无连接的，提供不可靠传输，头部信息短，而且不存在队头阻塞问题，google以UDP为基础并在上面建立quic协议，保障UDP的可靠传输

```
HTTP/2.0 的主要不足包括：
需要在客户端和服务器之间建立一个持久的连接，这需要进行握手等操作，导致延迟比较大。
头部压缩算法虽然可以压缩头部信息，但是对于一些重复较少的请求，压缩的效果并不好。
HTTP/2.0 的流量控制机制可能存在一些问题，比如服务器可能会通过发送 RST_STREAM 帧来关闭某个流，但客户端可能并没有收到该帧，导致客户端一直等待响应，浪费了带宽。
HTTP/3.0 是基于 QUIC 协议的，采用了 UDP 作为底层传输协议。相比于 TCP，UDP 更加轻量级，不需要建立连接，同时还能够避免 TCP 的队头阻塞问题。QUIC 协议还提供了类似于 TCP 的可靠传输机制，同时也支持多路复用和头部压缩等特性。HTTP/3.0 在保证可靠传输的同时，还具有较高的速度。
```



## 五：75

#### 谈谈变量提升?

js中变量提升是指通过var声明的变量，会将变量的声明提升到作用域顶端，这样即使是在var声明变量前访问变量也是可以访问到的，值为undefined，除了变量提升外函数声明式也会有函数提升，值得一提的是函数提升优先级大于变量提升，以相同名字声明函数的变量最终结果还是函数，而ES6中提出的let和const在使用时不会有变量提升，他们会创建一个块级作用域并造成暂时性死区，var声明变量在浏览器中会直接绑定到window对象属性上，而let和const不会。在let和const声明之前访问变量会报错。除此之外ES6中还有箭头函数，通过箭头函数声明匿名函数并赋值给一个变量这种方式叫函数表达式，他们也不会有函数提升。

```
谈谈变量提升?

js中变量提升是指通过var声明的变量，会将变量的声明提升到作用域顶端，这样即使是在var声明变量前访问变量也是可以访问到的，值为undefined，除了变量提升外函数声明式也会有函数提升，值得一提的是函数提升优先级大于变量提升，以相同名字声明函数的变量最终结果还是函数，而ES6中提出的let和const在使用时不会有变量提升，他们会创建一个块级作用域并造成暂时性死区，var声明变量在浏览器中会直接绑定到window对象属性上，而let和const不会。在let和const声明之前访问变量会报错。除此之外ES6中还有箭头函数，通过箭头函数声明匿名函数并赋值给一个变量这种方式叫函数表达式，他们也不会有函数提升。
```



#### new操作符具体做了什么?

new操作符首先拷贝一个原型对象，绑定this到这个原型对象，执行构造函数，判断构造函数返回值，如果是对象则返回这个对象，如果不是则返回this。

```
new 操作符的具体执行过程：
创建一个空对象，作为将要返回的对象实例。
将这个空对象的原型(__proto__)指向构造函数的原型对象(prototype)。
将构造函数的 this 绑定到这个空对象上，这样构造函数内部 this 指向的就是这个空对象。
执行构造函数，将实例对象作为函数的上下文 this 进行初始化赋值操作。
判断构造函数返回的值类型，如果返回值是对象，则直接返回该对象；否则返回这个实例对象。
```



#### 介绍下盒子模型?

盒子模型分两种，一种叫标准盒模型(content-box)，一种叫怪异盒模型/IE盒模型(border-box)。所有的盒模型都由以下几个部分组成：content padding border margin，不同在于标准盒模型的height = content高度(width同理)，而怪异盒模型的height = content+padding+border高度(width同理)

有哪些方式可以使div居中

父盒子宽高固定时，可以使用margin: auto

子盒子宽高固定时，可以使用:position + margin负值

都不固定时，可以使用flex居中，grid居中，position+transform居中



#### 有听过前端性能优化指标RAIL吗?

```
RAIL 是一种前端性能优化指标，它是由 Google 提出的一种性能优化模型，用于帮助开发者评估和优化 Web 应用程序的性能。RAIL 模型包含四个方面的性能指标：

Response（响应）：指应用程序对用户输入的响应时间，包括输入响应时间和动画响应时间。在 RAIL 模型中，建议将响应时间控制在 100 毫秒以内，这可以让用户感觉到应用程序的响应速度非常快。

Animation（动画）：指应用程序中动画的帧率和流畅度。在 RAIL 模型中，建议将动画的帧率控制在 60 帧/秒以上，这样可以让动画看起来非常流畅。

Idle（空闲）：指应用程序在空闲时所做的工作，包括预加载、缓存、预处理和预渲染等。在 RAIL 模型中，建议最大化利用空闲时间来执行这些任务，以提高应用程序的性能。

Load（加载）：指应用程序的初始加载时间和资源加载时间。在 RAIL 模型中，建议将初始加载时间控制在 1 秒以内，资源加载时间控制在 5 秒以内，这可以让用户感觉到应用程序的加载速度非常快。
```



#### 进程和线程的区别?

进程时计算机分配资源的最小单位，线程是计算机调度的最小单位。进程中可以包含多个线程，且这些线程间共享同一个进程分配的资源，也就是说线程间的资源是共享的，所以他们之间切换的开销很小，而进程间资源是不共享的，在进程间切换需要保存当前上下文环境，开销较大，并且进程间需要特别的通信方法，比如：管道pipe(+命名管道)，socket，共享存储块，消息队列，信号量传输。



#### tcp滑动窗口是什么?

滑动窗口是一种控制流量的机制，它在两端分别维护了一个发送窗口和一个接收窗口，保证了传输的速度不会过快，并且发送方发送后需要等待接收方回复确认信息后才会继续发送，保证了数据的完整性

```
TCP滑动窗口是TCP协议中用于实现可靠数据传输的一种流量控制机制。在TCP连接中，发送方和接收方都会维护一个窗口，用于控制数据的传输速率和流量控制。

TCP滑动窗口的实现方式是通过序号和确认号来实现的。发送方维护一个发送窗口，其中包含已发送但未收到确认的数据的序号范围。接收方维护一个接收窗口，其中包含已接收但未被确认的数据的序号范围。发送方只有在收到接收方的确认消息后，才会将窗口向前滑动，继续发送下一批数据。

TCP滑动窗口的大小可以根据网络情况动态调整，以适应不同的网络条件。如果网络拥塞或带宽不足，接收方可以通过发送窗口的大小来告诉发送方可以发送的数据量。发送方根据接收方的窗口大小来控制发送速率，以避免网络拥塞。

总之，TCP滑动窗口是一种流量控制机制，它可以保证数据的可靠传输，并且可以根据网络情况动态调整窗口大小，以提高网络的利用率和性能。
```



## 六：80

#### 什么是立即执行函数?

立即执行函数IIFE，是一种特殊的函数，他在声明后会立刻执行一次并返回函数返回值。这里举个例子(()=>{console.log(1)})()，立即执行函数中的函数声明式可以是匿名函数，并且会建立函数作用域，而且立即执行的函数无法被外界调用，也属于闭包的一种私有函数实现方式。

```
立即执行函数（IIFE）是一种将函数声明与函数执行结合在一起的技术，通常用于创建私有作用域、模块化代码、避免变量污染等场景。

IIFE的基本语法如下：

(function() {
  // 这里是立即执行函数中的代码
})();
这个函数声明被包裹在一对圆括号中，紧接着加上一对空的圆括号，这样就可以立即执行这个函数。这个函数在执行后，会返回一个值，如果需要，可以将这个返回值保存在变量中。

IIFE的另一个常见用法是将全局变量传入到函数中，避免全局变量污染。例如：

(function(window, document) {
  // 这里是立即执行函数中的代码
})(window, document);
在这个例子中，将全局变量window和document作为参数传入到立即执行函数中，并在函数内部使用它们。这样可以避免全局变量污染，同时也可以让代码更加模块化和可维护。

需要注意的是，IIFE中定义的变量只在函数内部有效，函数执行完毕后，这些变量就会被销毁，不会污染全局作用域。同时，IIFE也可以返回一个对象或者函数，让外界可以访问到其中的属性和方法，这样就可以实现模块化的代码结构。
```

#### 谈下事件循环机制？

谈到事件循环Event Loop，我们要先谈事件循环为什么会出现，他的出现解决了什么问题。首先要明确一点就是js是一门会进行UI操作的语言，所有操作UI的语言都应该是单线程的，多线程操作可能导致UI操作混乱，js毫无疑问也是一门单线程的语言，但单线程意味着可能会出现长任务，导致线程阻塞，比如网络请求等，如果线程阻塞，后面的操作无法完成，页面就可能会卡住，所以出现了事件循环机制来解决这个问题。事件循环中存在一个主线程和一个任务队列，当执行到异步任务时将其放入任务队列中，继续执行其他同步任务，直到主线程清空后，通过一个for循环不断的从任务队列中读取新的任务执行，这就是事件循环机制了。

```
事件循环（Event Loop）是JavaScript中的一种机制，用于处理异步任务和回调函数。

在JavaScript中，所有的任务可以分为两类：同步任务和异步任务。同步任务是按照顺序依次执行的任务，而异步任务则是需要等待某些条件满足后才能执行的任务，例如定时器、网络请求、事件回调等。

在事件循环机制中，JavaScript引擎会维护一个任务队列（task queue），所有的异步任务都会被放入这个任务队列中。当异步任务完成后，会将对应的回调函数放入任务队列中，等待主线程空闲后执行。

主线程会不停地从任务队列中读取任务，如果当前任务为同步任务，则直接执行；如果当前任务为异步任务，则等待条件满足后再执行对应的回调函数。这个过程就是事件循环。

需要注意的是，事件循环中存在一个微任务队列（micro task queue），用于处理一些优先级较高的任务，例如Promise的回调函数、process.nextTick等。当任务队列中的任务全部执行完成后，会先处理微任务队列中的任务，再继续处理任务队列中的任务。

另外，需要注意的是，事件循环机制的实现可能存在差异，不同的浏览器和JavaScript引擎可能会有不同的实现方式，因此在编写异步代码时，需要根据具体的环境和需求选择合适的实现方式。
```

#### css优先级是怎么计算的？

css优先级是特殊性值并按照加权计算的 例如行内样式优先级为1000，id选择器为优先级为100 class选择器为10 标签选择器为1等，而采用诸如父子选择器这种时会将优先级进行一个加法，最后展现优先级最高的样式，特别的是!important属性会给予样式最高优先级

```
CSS优先级是一种用于确定样式优先级的机制，它是通过对选择器的特殊性值进行加权计算来确定的。

每个选择器都有一个特殊性值（specificity），它是由四个部分组成：行内样式、ID选择器、类选择器和标签选择器。其中行内样式的特殊性值最高，为1000，ID选择器的特殊性值为100，类选择器和属性选择器的特殊性值为10，标签选择器和伪类选择器的特殊性值为1。如果使用了通配符选择器，其特殊性值为0。

当多个选择器作用于同一个元素时，CSS引擎会计算它们的特殊性值，然后比较它们的大小，以确定应该使用哪个样式。

如果两个选择器的特殊性值相等，那么后面的选择器会覆盖前面的选择器。如果两个选择器的特殊性值不相等，那么特殊性值大的选择器会覆盖特殊性值小的选择器。

当存在多个选择器具有相同的特殊性值时，CSS引擎会将它们的特殊性值相加，然后比较它们的大小。

最后，如果某个样式使用了!important属性，那么它的优先级最高，将覆盖其他所有样式。

需要注意的是，CSS优先级只是一种用于确定样式优先级的机制，实际应用中还需要考虑其他因素，例如样式的继承和层叠顺序等。
```

#### CSS相关的性能优化？

首先是样式加载，可以在head中添加link标签导入样式，也可以在css中采用@import导入，前者的兼容性更好，并且是并行加载的。css修改标签样式，可能会引起回流与重绘，比如更改宽高会引起回流+重绘，更改背景颜色会引起重绘等，我们可以通过一些方法，减少回流次数，比如脱离文档流，在操作结束后再更改回来，特别注意的是animation操作可能会引起多次回流+重绘，脱离文档流可以有效减少回流次数。选择器方面，少使用通配符选择器，父子标签选择器这类。

```
将样式表放在头部 - 将样式表放在<head>标签中，可以让浏览器更快地渲染页面，因为样式表可以在页面中的其他资源加载完成之前加载和解析。

避免使用@import - 如果必须使用多个样式表，最好使用<link>标签，因为它可以并行加载，而@import是串行加载的。

精简CSS代码 - 删除不必要的空格、注释和代码，可以减小文件大小，使加载和解析更快。

减少HTTP请求数 - 合并多个CSS文件为一个文件，可以减少HTTP请求数，从而提高性能。

避免使用通配符选择器 - 通配符选择器（*）会匹配页面中的每个元素，因此使用它会降低性能。

避免使用过于复杂的选择器 - 过于复杂的选择器会增加样式匹配的计算量，从而降低性能。建议使用简单的选择器，如类选择器、ID选择器等。

避免使用!important - 使用!important会覆盖其他样式，从而增加样式匹配的计算量，降低性能。

避免使用昂贵的属性 - 一些属性，如box-shadow、border-radius和transform等，会增加计算量和重绘时间，因此应该谨慎使用。

避免频繁的回流和重绘 - 回流和重绘是非常昂贵的操作，因此应该尽量避免频繁发生。可以使用缓存DOM元素、使用translate代替top和left、使用脱离文档流等方法来减少回流和重绘。

使用CSS预处理器 - CSS预处理器（如Sass和Less）可以提高CSS的可维护性，同时也可以生成更小、更高效的CSS文件。
```

#### 谈下webpack loader机制？

webpack是一个打包工具，默认只支持js文件的打包，如果要打包其他文件就需要对应的loader，每一个loader都是一个翻译官，它类似于一个函数，将不同类型的文件转换成webpack能够处理的模块

```
Webpack是一个模块化打包工具，可以将多种类型的资源（如JS、CSS、图片等）打包成一个或多个Bundle，以便于在浏览器中使用。Webpack的核心机制是Loader和Plugin。

Loader是Webpack中用于解析和转换文件的机制，它可以将不同类型的文件（如CSS、图片、字体等）转换为Webpack可以处理的模块。每个Loader都是一个函数，它负责将源文件转换成模块输出，然后交给Webpack进行进一步的处理。

在Webpack的配置中，可以通过module.rules配置项来定义Loader。每个rule包含一个test属性（用于匹配文件类型）、一个use属性（用于指定对应的Loader）和一些可选的属性（如exclude、include等）。当Webpack遇到匹配的文件时，会按照顺序依次使用对应的Loader进行转换，最后输出一个JavaScript模块。

除了常见的Loader（如css-loader、babel-loader等），Webpack还支持自定义Loader。自定义Loader需要遵循一定的规范，主要包括输出JavaScript模块、使用Node.js API等。

总的来说，Loader是Webpack的重要机制之一，它允许开发者对各种类型的文件进行解析和转换，从而实现打包和优化。
```

#### 进程通信方式有哪些？

管道，命名管道，socket，消息队列，共享存储块，信号量传输



## 七：75

#### react fiber有哪些优点，怎样做到的?

fiber支持可中断更新、优先级调度，并发模式，时间切片。

浏览器是60hz的，也就是大约16.7ms进行一次刷新，而react采用虚拟dom和diff算法，如果一次更新的时长过长导致剩余事件不够浏览器完成样式计算，布局和绘制，就会造成卡顿现象，于是react16提出了fiber架构。fiber架构主要用以解决老版本的一些问题，老版本的react协调方法为stack reconciel，采用递归的方法更新组件，并且是不可中断的，fiber架构下提供了可中断的更新方法，每次render阶段通过shouldYield()方法来判断浏览器是否还有空闲时间，如果有才进行更新，并且在此基础上设计了time slice时间分片，通过将任务拆分为一段段小任务来执行（一个小任务大约5ms），解决了cpu瓶颈，并且在fiber架构中提出scheduler，可以实现优先级调度，并提供部分api支持开发人员操控更新优先级

```
React Fiber 是 React16 中引入的新的协调引擎，相对于 React15 中的 Stack Reconciler，它具有以下优点：
支持可中断更新：React Fiber 可以将一个长时间运行的渲染任务分割成多个小任务，每个小任务运行一段时间，就可以中断执行，让出 CPU 时间片，避免了页面卡顿现象的出现。
支持优先级调度：React Fiber 可以根据任务的优先级动态调整任务的执行顺序，优先处理优先级高的任务，提高应用的响应速度和流畅度。
支持并发模式：React Fiber 可以同时处理多个任务，即在渲染的过程中，可以中断当前任务，执行其他任务，提高了渲染的效率和性能。
支持时间切片：React Fiber 可以将一个大任务分割成多个小任务，每个小任务执行一定时间后，检查是否还有时间片可用，如果没有则让出 CPU 时间片，避免了长时间的渲染导致页面卡顿的问题。
React Fiber 实现了这些优点的关键在于引入了 Fiber 数据结构，将渲染过程拆分成多个阶段，每个阶段执行完毕后，会检查当前是否有更高优先级的任务需要处理，如果有，就会中断当前任务，处理更高优先级的任务，然后再恢复当前任务的执行。
同时，React Fiber 还提供了 Scheduler API，开发者可以通过这些 API 来控制任务的优先级和执行顺序，从而更好地管理应用的性能和响应速度。
```

#### 谈谈你对作用域的理解?

作用域是一种变量保护机制，他保障了作用域内可以访问到作用域外的变量方法，作用域内的变量方法等不被作用域外访问到，多个作用域间构成了一个作用域链，对变量进行查找时会顺着作用域链往上查找，可以利用作用域的概念创建私有变量比如闭包

```
作用域是指在程序中定义变量的区域，它决定了变量的可见性和生命周期。在 JavaScript 中，作用域分为全局作用域和局部作用域（函数作用域和块级作用域）。

全局作用域中定义的变量可以在代码的任何地方访问，而局部作用域中定义的变量只能在该作用域内访问。在多个作用域嵌套的情况下，内部作用域可以访问外部作用域的变量，但是外部作用域不能访问内部作用域的变量。这种嵌套关系形成了作用域链，它决定了变量的查找顺序。

JavaScript 中的作用域是静态的，也就是说，在程序执行之前就已经确定了变量的作用域。而在代码执行过程中，变量的值可以发生改变，在函数内部定义的变量也可以在函数外部被访问（例如使用闭包）。

作用域的概念非常重要，它不仅可以帮助我们避免变量名冲突，还可以通过闭包等技术实现模块化编程和封装私有变量等高级功能。在编写 JavaScript 代码时，理解作用域的概念和原理，可以更好地掌握语言特性，写出更加健壮和高效的代码。
```

#### 双飞翼/圣杯布局?

圣杯布局无非在双飞翼基础上加了header和footer，这里我就演示一下双飞翼布局:

父盒子flex child1和child3给固定宽度，child2 flex: 1

采用浮动布局也可

浮动元素会造成什么影响，如何清除浮动

高度塌陷，文字围绕，布局错乱。伪元素after中设置clear:both

```
添加 clear 属性
可以在浮动元素的下方添加一个空元素，并设置其 clear 属性为 both。这样可以清除浮动，使得下方的元素不再受到浮动元素的影响。
使用 overflow 属性
可以在浮动元素的容器上设置 overflow 属性为 auto 或 hidden。这样可以清除浮动，使得容器可以包含浮动元素。
使用 clearfix
可以使用 clearfix 类来清除浮动。clearfix 类可以在浮动元素的容器上设置，它会创建一个伪元素，并设置 clear 属性为 both。这样可以清除浮动，而不需要在 HTML 中添加额外的元素。
```

#### 网站首页有大量的图片，加载很慢，如何去优化呢？

通常情况下，网页会加载所有的图片，这样就有可能导致图片加载缓慢。对此我们可以对图片进行懒加载优化，懒加载的意思就是只加载我们视图窗口中出现的图片，可以通过自定义属性data-src来做，监听滚动事件或者使用intersectionObserver对象。

描述下浏览器从输入网址到页面展现的整个过程?

浏览器获取并判断输入网址内容，如果是不符合URL格式的交由搜索引擎搜索，如果是符合的则进行域名解析，现在本机内寻找浏览器和操作系统是否有缓存，如果没有则向DNS服务器请求，DNS服务器向根服务器请求，根服务器向顶级域名服务器请求这样，直到某一层返回了对应的ip地址。通过ip地址三次握手建立TCP连接，发送http请求获取资源，服务端接收请求并处理，返回响应值，客户端接收响应值，解析html，加载样式，构建dom树，构建cssom树，合成渲染树，渲染节点到浏览器，用户关闭页面后4次回收断开TCP连接

```
用户在浏览器地址栏中输入网址。
浏览器获取并解析网址内容，判断是否符合 URL 格式。
如果不符合 URL 格式，交由搜索引擎搜索；如果符合 URL 格式，则进行域名解析。
浏览器首先在本机内寻找浏览器缓存、操作系统缓存和路由器缓存中是否有相应的 DNS 记录。如果没有，则向 DNS 服务器发送请求，以获取相应的 IP 地址。
DNS 服务器向根服务器发送请求，根服务器返回顶级域名服务器的地址。
DNS 服务器向顶级域名服务器发送请求，顶级域名服务器返回次级域名服务器的地址。
DNS 服务器向次级域名服务器发送请求，次级域名服务器返回相应主机的 IP 地址。
浏览器使用获取到的 IP 地址，通过三次握手建立 TCP 连接。
浏览器向服务器发送 HTTP 请求，请求页面资源。
服务器接收请求，处理请求并返回响应值。
浏览器接收响应值，解析 HTML，加载样式，构建 DOM 树，构建 CSSOM 树。
合成渲染树（Render Tree），渲染节点到浏览器。
浏览器将页面展示给用户，用户可以进行交互操作。
当用户关闭页面或者浏览器时，浏览器通过四次握手断开 TCP 连接。
```

#### uglify原理的是什么?

```
Uglify是一种JavaScript代码压缩工具，用于减小JavaScript文件的体积，从而提高网页的加载速度。Uglify的原理主要包括两个方面：

代码压缩：Uglify会对JavaScript代码进行压缩，主要包括以下几个方面：

删除代码中的注释、空格、换行符等无用字符。
将变量名、函数名等改为较短的名称，以减小文件大小。
将相邻的语句合并为一行，以减小文件大小。
将常量直接替换为字面量，以减小文件大小。
将代码中的if语句、for语句等转换为更紧凑的形式，以减小文件大小。
代码混淆：Uglify还会对JavaScript代码进行混淆，主要包括以下几个方面：

将变量名、函数名等改为难以理解的名称，以增加代码的可读性。
将代码中的字符串、数字等直接量进行编码，以增加代码的可读性。
将代码中的函数、变量等进行重组，以增加代码的可读性。
通过代码压缩和混淆，Uglify可以将JavaScript文件的大小减小到最小，并且使得代码难以被阅读和理解，从而保护JavaScript代码的安全性。
```

#### tcp重试机制?

```
TCP协议还使用了序列号和确认号来保证数据的可靠传输。发送方会给每个数据包分配一个唯一的序列号，接收方收到数据包后会返回一个确认号，确认号表示已成功接收了序列号之前的所有数据。如果发送方在一定时间内没有收到确认信息，就会认为数据丢失了，于是就会重新发送数据。如果接收方收到重复的数据包，就会忽略它，因为接收窗口已经移动过这个序列号了。

TCP协议还使用了滑动窗口机制来实现流量控制和拥塞控制。发送方和接收方各自维护一个窗口，用于限制数据的发送和接收。发送方通过接收方返回的窗口大小来控制发送速度，接收方通过发送窗口大小来控制接收速度。如果发送方发送的数据超出了接收方的窗口大小，接收方就会返回一个零窗口通知，告诉发送方暂停发送数据。如果发送方收到了多个零窗口通知，就会认为网络出现了拥塞，于是就会减少发送速度，以避免网络拥塞。
```



## 八：



## 九：



## 十：

