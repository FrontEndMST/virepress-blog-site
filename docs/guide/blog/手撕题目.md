# 手撕题目

转眼已经到了3月春招季，手撕又是面试躲不过的一关，在这里记录一下手撕题目

## JS题目

```js
// Object.create()
function create(obj) {
  function F() {}
  F.prototype = obj;
  return new F();
}

// instanceof
function myInstanceof(obj, obj2) {
  let proto = Object.getPrototypeOf(obj);
  const prototype = obj2.prototype;
  while (proto) {
    if (proto === prototype) {
      return true;
    }
    proto = Object.getPrototypeOf(proto);
  }
  return false;
}

// new
function myNew(fn, ...args) {
  const ans = Object.assign(fn);
  const value = fn.apply(ans, args);
  return value instanceof Object ? value : ans;
}

// debounce防抖
function debounce(fn, delay) {
  let timer = null;
  return function (...args) {
    timer && clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

// debounce节流
function debounce(fn, delay) {
  let timer = +new Date();
  return function (...args) {
    let newTimer = +new Date();
    if (newTimer - timer <= delay) {
      fn.apply(this, args);
      timer = +new Date();
    }
  };
}

// call
Function.prototype.myCall = function (context, ...args) {
  if (typeof this !== "function") {
    throw new Error("type error");
  }
  context ||= window;
  context.fn = this;
  const result = context.fn(...args);
  delete context.fn;
  return result;
};

// apply
Function.prototype.myApply = function (context, args) {
  if (typeof this !== "function") {
    throw new Error("type error");
  }
  context ||= window;
  context.fn = this;
  const result = context.fn(...args);
  delete context.fn;
  return result;
};

// bind
Function.prototype.myBind = function (context) {
  if (typeof this !== "function") {
    throw new Error("type error");
  }
  const self = this;
  return function () {
    return self.apply(context, arguments);
  };
};

// 函数柯里化
function curry(fn) {
  const judge = (...args) =>
    args.length >= fn.length
      ? fn(...args)
      : (...args2) => judge(...args, ...args2);
  return judge;
}

// 深拷贝
function deepClone(obj) {
  if (Array.isArray(obj)) {
    return obj.map((item) => deepClone(item));
  } else if (obj instanceof Object) {
    return Object.fromEntries(
      Object.entries(obj).map(([key, value]) => [key, deepClone(value)])
    );
  } else {
    return obj;
  }
}

// 打乱数组顺序
function outOfOrder(arr) {
  arr.forEach((_, index, array) => {
    const randomIndex = ~~(Math.random() * (array.length - 1 - index)) + index;
    [array[index], array[randomIndex]] = [array[randomIndex], array[index]];
  });
  return arr;
}

// 数组扁平化
function flat1(arr) {
  return arr.reduce((prev, cur) => {
    if (Array.isArray(cur)) {
      return prev.concat(flat1(cur));
    } else {
      return prev.concat(cur);
    }
  }, []);
}

// flat方法
function flat(arr, depth) {
  if (!Array.isArray(arr) || depth <= 0) {
    return arr;
  }
  return arr.reduce((prev, cur) => {
    if (Array.isArray(cur)) {
      return prev.concat(flat(cur, depth - 1));
    } else {
      return prev.concat(cur);
    }
  }, []);
}

// 数组push方法
Array.prototype.push = function () {
  for (let i = 0; i < arguments.length; i++) {
    this[this.length] = arguments[i];
  }
  return this.length;
};

Array.prototype.filter = function (callback) {
  const res = [];
  for (let i = 0; i < this.length; i++) {
    callback(this[i]) && res.push(this[i]);
  }
  return res;
};

// 数组map方法
Array.prototype.map = function (callback) {
  const res = [];
  for (let i = 0; i < this.length; i++) {
    res.push(callback(this[i]));
  }
  return res;
};

// 实现任意数量数字相加函数add(1)(2)(3)(4)
function fn() {
  let result = [];
  function add(...args) {
    result = result.concat(args);
    return add;
  }
  // 调用是使用+add(1,2,3)(4)，此时由于add是function，会先转化成string，再转化number，重写toString方法实现
  add.toString = () => result.reduce((pre, cur) => pre + cur);
  return add;
}
// 如果是已知相加数目 可以调用currying方法实现

// 发布订阅模式
class EventCenter {
  handlers = {};

  addEventListener(type, handler) {
    if (!handlers[type]) {
      handlers[type] = [];
    }
    this.handlers[type].push(handler);
  }

  dispatch(type, params) {
    if (!this.handlers[type]) {
      return new Error("事件未注册");
    }
    this.handlers[type].forEach((handle) => handle(...params));
  }

  removeEventListener(type, handler) {
    if (!this.handlers[type]) {
      return new Error("事件未注册");
    }
    if (!handler) {
      delete this.handlers[type];
    }
    const index = this.handlers[type].indexOf(handler);
    if (index === -1) {
      return new Error("无该绑定事件");
    } else {
      this.handlers[type].splice(index, 1);
      if (!this.handlers[type].length) {
        delete this.handlers[type];
      }
    }
  }
}

// Object.defineProperty数据劫持(简易版)
{
  const obj = {
    name: "luowei",
    age: 20,
  };
  const p = {};
  Object.defineProperty(p, key, {
    get() {
      return obj[key];
    },
    set(val) {
      obj[key] = val;
    },
  });
}

// Proxy数据劫持(简易版)
{
  const obj = {
    name: "luowei",
    age: 20,
  };
  const proxy = new Proxy(obj, {
    get(target, propName) {
      return Reflect.get(target, propName);
    },
    set(target, propName, value) {
      Reflect.set(target, propName, value);
    },
    deleteProperty(target, propName) {
      return Reflect.deleteProperty(target, propName);
    },
  });
}

// 实现路由
class Route {
  constructor() {
    this.routes = {};
    this.currentHash = "";
    this.freshRoute = this.freshRoute.bind(this);
    window.addEventListener("load", this.freshRoute);
    window.addEventListener("hashchange", this.freshRoute);
  }

  storeRoute(path, callback) {
    this.routes[path] = callback || function () {};
  }
  freshRoute() {
    this.currentHash = location.hash.slice(1) || "";
    this.routes[this.currentHash]();
  }
}

// setTimeout实现setInterval
function mySetInterval(callback, delay) {
  const timer = {
    flag: true,
  };
  function interval() {
    if (timer.flag) {
      callback();
      setTimeout(interval, delay);
    }
  }
  setTimeout(interval, delay);
  return timer;
}

// setInterval实现setTimeout
function mySetTimeout(callback, delay) {
  const timer = setInterval(() => {
    clearInterval(timer);
    callback();
  }, delay);
}

// 实现jsonp
function addScript(src) {
  const script = document.createElement("script");
  script.src = src;
  script.type = "text/javascript";
  document.body.appendChild(script);
}

// 数组去重 1.Set 2.filter 3.双for
{
  const arr = [1, 2, 3, 1, 2, 3];
  [...new Set(arr)];
  arr.filter((item) => arr.indexOf(item) === index);
  // 双for就不说了
}
```

## TS题目

```

```

## Lodash题目

```

```

## Promise题目

```ts
enum Status {
  PENDING = "pending",
  REJECTED = "rejected",
  RESOLVED = "resolved",
}

abstract class OwnPromise {
  protected promiseResult: any = null;
  protected promiseStatus: Status = Status.PENDING;
  protected onFulFilledCallback: Array<any> = [];
  protected onRejectedCallback: Array<any> = [];
  static all(promises: Array<any>): MyPromise {
    throw new Error("未初始化函数");
  }
  static race(promises: Array<any>): MyPromise {
    throw new Error("未初始化函数");
  }
  static any(promises: Array<any>): MyPromise {
    throw new Error("未初始化函数");
  }
  constructor(
    executor: (
      resolve: (value: any) => void,
      reject: (reason: any) => void
    ) => void
  ) {
    throw new Error("未初始化函数");
  }
  resolve(value: any): void {
    throw new Error("未初始化函数");
  }
  reject(reason: any): void {
    throw new Error("未初始化函数");
  }
  then(
    onFulFilled?: (value: any) => any,
    onRejected?: (reason: any) => any
  ): MyPromise {
    throw new Error("未初始化函数");
  }
}

class MyPromise extends OwnPromise {
  static all(promises: Array<any>) {
    const result: any[] = [];
    return new MyPromise((resolve, reject) => {
      const addData = (value: any) => {
        result.push(value);
        if (result.length === promises.length) {
          resolve(result);
        }
      };
      promises.forEach(promise => {
        if (promise instanceof MyPromise) {
          promise.then(
            value => {
              addData(value);
            },
            reason => {
              reject(reason);
            }
          );
        } else {
          addData(promise);
        }
      });
    });
  }

  static race(promises: Array<any>) {
    return new MyPromise((resolve, reject) => {
      promises.forEach(promise => {
        if (promise instanceof MyPromise) {
          promise.then(
            value => {
              resolve(value);
            },
            reason => {
              reject(reason);
            }
          );
        } else {
          resolve(promise);
        }
      });
    });
  }

  static any(promises: Array<any>) {
    let count = 0;
    return new MyPromise((resolve, reject) => {
      promises.forEach(promise => {
        if (promise instanceof MyPromise) {
          promise.then(
            value => {
              resolve(value);
            },
            () => {
              count++;
              if (count === promises.length) {
                reject(new Error("All promises were rejected"));
              }
            }
          );
        } else {
          resolve(promise);
        }
      });
    });
  }

  constructor(
    executor: (
      resolve: (value: any) => void,
      reject: (reason: any) => void
    ) => void
  ) {
    super(executor);
    try {
      this.resolve = this.resolve.bind(this);
      this.reject = this.reject.bind(this);
      executor(this.resolve, this.reject);
    } catch (error) {
      this.reject(error);
    }
  }

  resolve(value: any) {
    if (this.promiseStatus !== Status.PENDING) {
      return;
    }
    this.promiseResult = value;
    this.promiseStatus = Status.RESOLVED;
    while (this.onFulFilledCallback.length) {
      this.onFulFilledCallback.shift()(this.promiseResult);
    }
  }

  reject(reason: any) {
    if (this.promiseStatus !== Status.PENDING) {
      return;
    }
    this.promiseResult = reason;
    this.promiseStatus = Status.REJECTED;
    while (this.onFulFilledCallback.length) {
      this.onRejectedCallback.shift()(this.promiseResult);
    }
  }

  then(onFulFilled?: (value: any) => any, onRejected?: (reason: any) => any) {
    onFulFilled =
      typeof onFulFilled === "function" ? onFulFilled : value => value;
    onRejected =
      typeof onRejected === "function"
        ? onRejected
        : reason => {
            throw new Error(`${reason}`);
          };
    const thenPromise = new MyPromise((resolve, reject) => {
      const resolvePromise = (callback: any) => {
        queueMicrotask(() => {
          try {
            const temp = callback(this.promiseResult);
            if (temp === thenPromise && temp != undefined) {
              throw new Error(`不能返回自身`);
            } else if (temp instanceof MyPromise) {
              temp.then(resolve, reject);
            } else {
              resolve(this.promiseResult);
            }
          } catch (error) {
            reject(error);
            throw new Error(`${error}`);
          }
        });
      };
      if (this.promiseStatus === Status.RESOLVED) {
        resolvePromise(onFulFilled);
      } else if (this.promiseStatus === Status.REJECTED) {
        resolvePromise(onRejected);
      } else if (this.promiseStatus === Status.PENDING) {
        this.onFulFilledCallback.push(resolvePromise.bind(this, onFulFilled));
        this.onRejectedCallback.push(resolvePromise.bind(this, onRejected));
      }
    });
    return thenPromise;
  }
}
```

