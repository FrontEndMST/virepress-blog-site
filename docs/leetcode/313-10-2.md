# 第 313 场(2022.10.2)

## Q1:（枚举）

给你两个正整数 `a` 和 `b` ，返回 `a` 和 `b` 的 **公** 因子的数目。

如果 `x` 可以同时整除 `a` 和 `b` ，则认为 `x` 是 `a` 和 `b` 的一个 **公因子** 。

示例 1：

```
输入：a = 12, b = 6
输出：4
解释：12 和 6 的公因子是 1、2、3、6 。
```

示例 2：

```
输入：a = 25, b = 30
输出：2
解释：25 和 30 的公因子是 1、5 。
```

> 提示：
>
> 1 <= a, b <= 1000
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/number-of-common-factors
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## Answer:

**explain:**

题目意思很清楚，数据范围也不大直接枚举即可

```ts
function commonFactors(a: number, b: number): number {
  const temp = Math.min(a, b);
  let count = 0;
  for (let i = 1; i <= temp; i++) {
    if (a % i === 0 && b % i === 0) {
      count++;
    }
  }
  return count;
}
```

## Q2:（遍历）

给你一个大小为 m x n 的整数矩阵 grid 。

按以下形式将矩阵的一部分定义为一个 沙漏 ：

![img](/images/img.jpg)

返回沙漏中元素的 最大 总和。

注意：沙漏无法旋转且必须整个包含在矩阵中。

示例 1：

![1](/images/1.jpg)

```
输入：grid = [[6,2,1,3],[4,2,1,5],[9,2,8,7],[4,1,2,9]]
输出：30
解释：上图中的单元格表示元素总和最大的沙漏：6 + 2 + 1 + 2 + 9 + 2 + 8 = 30 。
```

示例 2：

![img](/images/2.jpg)

```
输入：grid = [[1,2,3],[4,5,6],[7,8,9]]
输出：35
解释：上图中的单元格表示元素总和最大的沙漏：1 + 2 + 3 + 5 + 7 + 8 + 9 = 35 。
```

> 提示：
>
> m == grid.length
> n == grid[i].length
> 3 <= m, n <= 150
> 0 <= grid[i][j] <= 106
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/maximum-sum-of-an-hourglass
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## Answer:

**explain:**

同样是遍历即可，假设当前节点为`(i, j)`，沙漏总和为：

![1](/images/1.1.jpg)

注意考虑边界

```ts
function calculate(i: number, j: number, grid: number[][]): number {
  return (
    grid[i][j] +
    grid[i][j + 1] +
    grid[i][j + 2] +
    grid[i + 1][j + 1] +
    grid[i + 2][j] +
    grid[i + 2][j + 1] +
    grid[i + 2][j + 2]
  );
}

function maxSum(grid: number[][]): number {
  let ans = 0;
  for (let i = 0; i < grid.length - 2; i++) {
    for (let j = 0; j < grid[0].length - 2; j++) {
      ans = Math.max(ans, calculate(i, j, grid));
    }
  }
  return ans;
}
```

## Q3:（贪心）

给你两个正整数 num1 和 num2 ，找出满足下述条件的整数 x ：

- `x` 的置位数和 num2 相同，且
- `x` XOR `num1` 的值 最小

注意 XOR 是按位异或运算。

返回整数 `x` 。题目保证，对于生成的测试用例， `x` 是 唯一确定 的。

整数的 **置位数** 是其二进制表示中 1 的数目。

示例 1：

```
输入：num1 = 3, num2 = 5
输出：3
解释：
num1 和 num2 的二进制表示分别是 0011 和 0101 。
整数 3 的置位数与 num2 相同，且 3 XOR 3 = 0 是最小的。
```

示例 2：

```
输入：num1 = 1, num2 = 12
输出：3
解释：
num1 和 num2 的二进制表示分别是 0001 和 1100 。
整数 3 的置位数与 num2 相同，且 3 XOR 1 = 2 是最小的。
```

> 提示：
>
> 1 <= num1, num2 <= 109
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/minimize-xor
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## Answer:

**explain:**

首先要理解异或运算的概念：**相同为 0，不同为 1**

已知`x`的二进制串中`1`的个数与`num2`相同，要使`x XOR num1`值最小，这里分三种情况讨论，我们采用以下三个例子：

1. ```
   num1 = 3, num2 = 5
   num1 = 0011
   num2 = 0101
   num1与num2置位数相同，x=num1，异或值为0（最小）
   ```

2. ```
   num1 = 25, num2 = 72
   num1 = 0011001
   num2 = 1001000
   num1置位数>num2置位数，我们需要调整x中的1与num1的高位1位置相同，通过异或消去高位1
   num1 = 0011001
   x    = 0011000
   此时的异或值为0000001 = 1
   ```

3. ```
   num1 = 1, num2 = 12
   num1 = 0001
   num2 = 1100
   num1置位数<num2置位数，我们需要将1移到x的低位
   num1 = 0001
   x    = 0011
   此时的异或值为0010 = 3
   ```

如果你有仔细观察，可以发现`x`的值是和`num1`紧密相关的，这里我们设`num1`置位数为`l1`，`num2`置位数为`l2`

- `l1===l2`: 自然不必多说，直接输出 num1 就完事了
- `l1>l2`: 调整`x`中的`1`与`num1`的高位 1 位置相同，也就相当于消去在`num1`低位的`(l1-l2)`个`1`
- `l1<l2`: 将多余的`(l2-l1)`个`1`移到`x`的低位，也就相当于在`num1`低位加上`(l2-l1)`个`1`

```ts
function minimizeXor(num1: number, num2: number) {
  let temp1 = {};
  let temp2 = {};
  for (let i = 0, temp = num1; temp > 0; temp >>= 1, i++) {
    if (temp % 2 !== 0) {
      temp1[i] = 1;
    }
  }
  for (let i = 0, temp = num2; temp > 0; temp >>= 1, i++) {
    if (temp % 2 !== 0) {
      temp2[i] = 1;
    }
  }
  const len1 = Object.values(temp1).length;
  const len2 = Object.values(temp2).length;
  if (len1 === len2) {
    return num1;
  } else if (len1 > len2) {
    let index = len1 - len2;
    let ans = num1;
    for (let i = 0; index > 0; i++) {
      if (temp1[i] === 1) {
        ans -= 2 ** i;
        index--;
      }
    }
    return ans;
  } else {
    let index = len2 - len1;
    let ans = num1;
    for (let i = 0; index > 0; i++) {
      if (temp1[i] !== 1) {
        ans += 2 ** i;
        index--;
      }
    }
    return ans;
  }
}
```

## Q4:（线性 DP）

给你一个仅由小写英文字母组成的字符串 `s` 。在一步操作中，你可以：

删除 整个字符串 `s` ，或者
对于满足 `1 <= i <= s.length / 2` 的任意 `i` ，如果 `s` 中的 前 `i` 个字母和接下来的 `i` 个字母 相等 ，删除 前 `i` 个字母。
例如，如果 `s = "ababc"` ，那么在一步操作中，你可以删除 s 的前两个字母得到 `"abc"` ，因为 `s` 的前两个字母和接下来的两个字母都等于 `"ab"` 。

返回删除 `s` 所需的最大操作数。

示例 1：

```
 输入：s = "abcabcdabc"
 输出：2
 解释：

 - 删除前 3 个字母（"abc"），因为它们和接下来 3 个字母相等。现在，s = "abcdabc"。
 - 删除全部字母。
   一共用了 2 步操作，所以返回 2 。可以证明 2 是所需的最大操作数。
   注意，在第二步操作中无法再次删除 "abc" ，因为 "abc" 的下一次出现并不是位于接下来的 3 个字母。
```

示例 2：

```
 输入：s = "aaabaab"
 输出：4
 解释：

 - 删除第一个字母（"a"），因为它和接下来的字母相等。现在，s = "aabaab"。
 - 删除前 3 个字母（"aab"），因为它们和接下来 3 个字母相等。现在，s = "aab"。
 - 删除第一个字母（"a"），因为它和接下来的字母相等。现在，s = "ab"。
 - 删除全部字母。
   一共用了 4 步操作，所以返回 4 。可以证明 4 是所需的最大操作数。
```

示例 3：

```
输入：s = "aaaaa"
输出：5
解释：在每一步操作中，都可以仅删除 s 的第一个字母。
```

> 提示：
>
> 1 <= s.length <= 4000
> s 仅由小写英文字母组成
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/maximum-deletions-on-a-string
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## Answer:

先上代码，TS 坑太多了明天再写

```ts
// 这题没做对，参考力扣题解 灵茶山艾府 老师的题解
function deleteString(s: string): number {
  if (new Set(s.split("")).size === 1) {
    return s.length;
  }
  const length = s.length;
  const lcp = Array.from(new Array(length + 1), () =>
    new Array(length + 1).fill(0)
  );
  for (let i = length - 1; i >= 0; i--) {
    for (let j = length - 1; j > i; j--) {
      if (s[i] === s[j]) {
        lcp[i][j] = lcp[i + 1][j + 1] + 1;
      }
    }
  }
  const dp = Array(length).fill(0);
  for (let i = length - 1; i >= 0; i--) {
    for (let j = 1; i + j * 2 <= length; j++) {
      if (lcp[i][i + j] >= j) {
        dp[i] = Math.max(dp[i], dp[i + j]);
      }
    }
    dp[i]++;
  }
  return dp[0];
}
```
