# 313-10-2 周赛

## Q4:（线性 DP）

给你一个仅由小写英文字母组成的字符串 `s` 。在一步操作中，你可以：

删除 整个字符串 `s` ，或者
对于满足 `1 <= i <= s.length / 2` 的任意 `i` ，如果 `s` 中的 前 `i` 个字母和接下来的 `i` 个字母 相等 ，删除 前 `i` 个字母。
例如，如果 `s = "ababc"` ，那么在一步操作中，你可以删除 s 的前两个字母得到 `"abc"` ，因为 `s` 的前两个字母和接下来的两个字母都等于 `"ab"` 。

返回删除 `s` 所需的最大操作数。

示例 1：

```
 输入：s = "abcabcdabc"
 输出：2
 解释：

 - 删除前 3 个字母（"abc"），因为它们和接下来 3 个字母相等。现在，s = "abcdabc"。
 - 删除全部字母。
   一共用了 2 步操作，所以返回 2 。可以证明 2 是所需的最大操作数。
   注意，在第二步操作中无法再次删除 "abc" ，因为 "abc" 的下一次出现并不是位于接下来的 3 个字母。
```

示例 2：

```
 输入：s = "aaabaab"
 输出：4
 解释：

 - 删除第一个字母（"a"），因为它和接下来的字母相等。现在，s = "aabaab"。
 - 删除前 3 个字母（"aab"），因为它们和接下来 3 个字母相等。现在，s = "aab"。
 - 删除第一个字母（"a"），因为它和接下来的字母相等。现在，s = "ab"。
 - 删除全部字母。
   一共用了 4 步操作，所以返回 4 。可以证明 4 是所需的最大操作数。
```

示例 3：

```
输入：s = "aaaaa"
输出：5
解释：在每一步操作中，都可以仅删除 s 的第一个字母。
```

> 提示：
>
> 1 <= s.length <= 4000
> s 仅由小写英文字母组成
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/maximum-deletions-on-a-string
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## Answer:

**explain:**

枚举删除字母的长度`j`，具体操作如下：

```
abcabcdabc
枚举长度j，如果s[i:j]===s[i+j,i+2*j]，则消去
abcabcdabc => abcdabc
我们假设dp[i]表示删除后缀s[i:]需要的最大操作数
如果s[i:j]===s[i+j,i+2*j]， dp[i]=dp[i+J]+1，说明(i~j,i+1~2*j)可以产生一次操作
```

所以我们的问题变为了如何得知`s[i:j]===s[i+j,i+2*j]`(最长公共前缀)建立一个`lcp`二维数组，长度为`s.length+1`，如果`s[i]===s[j]`则`lcp[i][j] = lcp[i + 1][j + 1] + 1`

其中`lcp[i][j]`表示`s[i:]`和`s[j:]`的最长公共前缀

如上所说，`s[i:j]===s[i+j,i+2*j]`=>`lcp[i][j]>=j`

> 这里需要说明一下 TS/JS 的数组引用是不会变的，`Array(length+1).fill(Array(length+1).fill(0))`中第一维中数组并非独立的新数组，而是一个相同的数组

从后往前推，如果`s[i:j]===s[i+j,i+2*j]`=>`lcp[i][j]>=j`则`dp[i]=dp[i+j]+1`

这里需要开始先用`Set`进行特判，否则超内存

```ts
function deleteString(s: string): number {
  if (new Set(s.split("")).size === 1) {
    return s.length;
  }
  const length = s.length;
  const lcp = Array.from(new Array(length + 1), () =>
    new Array(length + 1).fill(0)
  );
  for (let i = length - 1; i >= 0; i--) {
    for (let j = length - 1; j > i; j--) {
      if (s[i] === s[j]) {
        lcp[i][j] = lcp[i + 1][j + 1] + 1;
      }
    }
  }
  const dp = Array(length).fill(0);
  for (let i = length - 1; i >= 0; i--) {
    for (let j = 1; i + j * 2 <= length; j++) {
      if (lcp[i][i + j] >= j) {
        dp[i] = Math.max(dp[i], dp[i + j]);
      }
    }
    dp[i]++;
  }
  return dp[0];
}
```
