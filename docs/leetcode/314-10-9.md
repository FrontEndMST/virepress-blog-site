# 314-10-9 周赛

## Q3:（贪心）

给你一个字符串` s` 和一个机器人，机器人当前有一个空字符串 `t `。执行以下操作之一，直到`s`和`t`都变成空字符串：

删除字符串`s`的 第一个 字符，并将该字符给机器人。机器人把这个字符添加到`t`的尾部。
删除字符串` t` 的 最后一个 字符，并将该字符给机器人。机器人将该字符写到纸上。
请你返回纸上能写出的字典序最小的字符串。

示例 1：

```
输入：s = "zza"
输出："azz"
解释：用 p 表示写出来的字符串。
一开始，p="" ，s="zza" ，t="" 。
执行第一个操作三次，得到 p="" ，s="" ，t="zza" 。
执行第二个操作三次，得到 p="azz" ，s="" ，t="" 。
```

示例 2：

```
输入：s = "bac"
输出："abc"
解释：用 p 表示写出来的字符串。
执行第一个操作两次，得到 p="" ，s="c" ，t="ba" 。
执行第二个操作两次，得到 p="ab" ，s="c" ，t="" 。
执行第一个操作，得到 p="ab" ，s="" ，t="c" 。
执行第二个操作，得到 p="abc" ，s="" ，t="" 。
```

示例 3：

```
输入：s = "bdda"
输出："addb"
解释：用 p 表示写出来的字符串。
一开始，p="" ，s="bdda" ，t="" 。
执行第一个操作四次，得到 p="" ，s="" ，t="bdda" 。
执行第二个操作四次，得到 p="addb" ，s="" ，t="" 。
```

> 提示：
>
> 1 <= s.length <= 10^5
> s 只包含小写英文字母。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/using-a-robot-to-print-the-lexicographically-smallest-string
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## Answer：

**explain:**

根据题目意思可以知道，在允许一个辅助栈的情况下，求最小字典序

贪心策略是：我们需要把字典序小的字母尽可能的放前面

例如：下标为`i`时，我们需要将`min(s[i:])`找到写在纸上，也就是`i`后面的`ascll`码最小值

这里我们首先可以考虑的是 通过一个数组`f[i]`来记录`s[i:]`的`ascll`码最小值，其中`f[s.length]='z'+1`

我们将每一个元素依次进栈，然后我们就可以进行判断 是否要将栈中内容弹出

- `stack[stack.length-1](等同于s[i])<f[i+1]`表明当前栈顶元素后面没有更小的字符，此时弹出写在纸上
- 否则不弹出 等待更小的字符入栈

> 这里需要注意不能使用`Array.shift()`和`Array.unshift()`，他们的复杂度更高，使用他们的复杂度会超出时间限制

```ts
function robotWithString(s: string): string {
  let f = Array(s.length + 1).fill(0);
  const z = "z";
  f[s.length] = z.charCodeAt(0) + 1;
  for (let i = s.length - 1; i >= 0; i--) {
    f[i] = Math.min(s[i].charCodeAt(0), f[i + 1]);
  }
  const stack = [];
  let ans = "";
  for (let i = 0; i < s.length; i++) {
    stack.push(s[i]);
    while (stack.length && stack[stack.length - 1].charCodeAt(0) <= f[i + 1]) {
      ans += stack.pop();
    }
  }
  return ans + stack.join("");
}
```

## Q4:（动态规划）

给你一个下标从`0`开始的 `m x n `整数矩阵`grid`和一个整数`k`。你从起点 `(0, 0) `出发，每一步只能往 下 或者往 右 ，你想要到达终点 `(m - 1, n - 1) `。

请你返回路径和能被` k` 整除的路径数目，由于答案可能很大，返回答案对 `10^9 + 7 `取余 的结果。

示例 1：

```
输入：grid = [[5,2,4],[3,0,5],[0,7,2]], k = 3
输出：2
解释：有两条路径满足路径上元素的和能被 k 整除。
第一条路径为上图中用红色标注的路径，和为 5 + 2 + 4 + 5 + 2 = 18 ，能被 3 整除。
第二条路径为上图中用蓝色标注的路径，和为 5 + 3 + 0 + 5 + 2 = 15 ，能被 3 整除。
```

示例 2：

```
输入：grid = [[0,0]], k = 5
输出：1
解释：红色标注的路径和为 0 + 0 = 0 ，能被 5 整除。
```

示例 3：

```
输入：grid = [[7,3,4,9],[2,3,6,2],[2,3,7,0]], k = 1
输出：10
解释：每个数字都能被 1 整除，所以每一条路径的和都能被 k 整除。
```

> 提示：
>
> m == grid.length
> n == grid[i].length
> 1 <= m, n <= 5 _ 104
> 1 <= m _ n <= 5 \* 104
> 0 <= grid[i][j] <= 100
> 1 <= k <= 50
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/paths-in-matrix-whose-sum-is-divisible-by-k
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## Answer：

**explain:**

将取的余数看作一个新的维度，定义`f[i][j][v]`表示从左上走到`(i, j)`且路径模`k`的结果为`v`时的路径数

- `f[i][j][grid[0][0] mod k] = 1`

- `f[i][j][(v + grid[i][j]) mod k] = f[i][j-1][v] + f[i-1][j][v]`

`f[grid.length - 1][grid[0].length - 1]][0]`为最终答案

```ts
function numberOfPaths(grid: number[][], k: number): number {
  const mod = 1e9 + 7;
  const m = grid.length,
    n = grid[0].length;
  const dp: number[][][] = Array.from(new Array(m + 1), () =>
    Array.from(new Array(n + 1), () => new Array(k).fill(0))
  );
  dp[0][1][0] = 1;
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      for (let v = 0; v < k; v++) {
        dp[i + 1][j + 1][(v + grid[i][j]) % k] =
          (dp[i + 1][j][v] + dp[i][j + 1][v]) % mod;
      }
    }
  }
  return dp[m][n][0];
}
```
